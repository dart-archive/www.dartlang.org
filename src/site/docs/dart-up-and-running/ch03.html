---
layout: book
title: "Chapter 3. A Tour of the Dart Libraries"
description: "Learn how to use each major Dart library feature."
has-permalinks: true
---
<h1 id="a-tour-of-the-dart-libraries"> {{ page.title }} </h1>


<p>This chapter shows you how to use the major features in Dart’s
  libraries. It’s just an overview, and by no means comprehensive. Whenever
  you need more details about a class, consult the <a class="ulink" href="http://api.dartlang.org/">Dart API reference.</a></p><aside><div class="alert"><strong>Warning: </strong>Expect major changes to the Dart libraries before Dart’s first
    production release.</div></aside>

<section>
<h4 id="TOC"> Contents </h4>
  <ol class="toc">
  <li><a href="#ch03-dartcore---strings-collections-and-more">dart:core - Numbers, collections, strings, and more</a><ol>
  <li><a href="#id627806">Numbers</a></li>
  <li><a href="#ch03-strings-and-regular-expressions">Strings and regular expressions</a></li>
  <li><a href="#ch03-collections">Collections</a><ol>
  <li><a href="#ch03-lists">Lists</a></li>
  <li><a href="#ch03-sets">Sets</a></li>
  <li><a href="#ch03-common-collection-methods">Common collection methods</a></li>
  <li><a href="#ch03-maps-aka-dictionaries-or-hashes">Maps</a></li>
  </ol></li>
  <li><a href="#ch03-dates-and-times">Dates and times</a></li>
  <li><a href="#ch03-utility-interfaces">Utility classes</a></li>
  <li><a href="#ch03-asynchronous-programming">Asynchronous programming</a></li>
  <li><a href="#ch03-exceptions">Exceptions</a></li>
  </ol></li>
  <li><a href="#ch03-dart-math">dart:math - Math and random</a></li>
  <li><a href="#ch03-dart-html-using-html5-apis">dart:html - Browser-based apps</a><ol>
  <li><a href="#ch03-manipulating-the-dom">Manipulating the DOM</a></li>
  <li><a href="#ch03-httprequest">Using HTTP resources with HttpRequest</a></li>
  <li><a href="#ch03-websockets">Sending and receiving real-time data with WebSockets</a></li>
  </ol></li>
  <li><a href="#ch03-dartisolate---concurrency-with-isolates">dart:isolate - Concurrency with isolates</a><ol>
  <li><a href="#ch03-isolate-concepts">Isolate concepts</a></li>
  <li><a href="#ch03-using-isolates">Using isolates</a><ol>
  <li><a href="#ch03-spawning-isolates">Spawning isolates</a></li>
  <li><a href="#ch03-sending-messages">Sending messages</a></li>
  <li><a href="#ch03-sending-any-type-of-object">Sending any type of object</a></li>
  <li><a href="#ch03-receiving-messages">Receiving messages</a></li>
  <li><a href="#ch03-receiving-replies">Receiving replies</a></li>
  <li><a href="#ch03-keeping-the-root-isolate-alive">Keeping the root isolate alive</a></li>
  </ol></li>
  </ol></li>
  <li><a href="#ch03-dartio---file-and-socket-io-for-command-line-apps">dart:io - I/O for command-line apps</a><ol>
  <li><a href="#ch03-files-and-directories">Files and directories</a></li>
  <li><a href="#ch03-io-http">HTTP clients and servers</a></li>
  </ol></li>
  <li><a href="#ch03-json">dart:json - Encoding and decoding objects</a></li>
  <li><a href="#ch03-uri">dart:uri - Manipulating URIs</a></li>
  <li><a href="#ch03-utf">dart:utf - Strings and Unicode</a></li>
  <li><a href="#ch03-crypto">dart:crypto - Hash codes and more</a></li>
  </ol>
</section>

    <div class="sect1" title="dart:core - Numbers, collections, strings, and more"><h2 id="ch03-dartcore---strings-collections-and-more"/>dart:core - Numbers, collections, strings, and more</h2><p>The Dart core library provides a small but critical set of
    built-in functionality. This library is automatically imported into every
    Dart program.</p><div class="sect2" title="Numbers"><h3 id="id627806"/>Numbers</h3><p>The dart:core library defines the num, int, and double classes,
      which have some basic utilities for working with numbers.</p><p>You can convert a string into an integer or double with the
      parse() methods of int and double, respectively.</p><pre class="screen">assert(int.parse('42') == 42);
assert(double.parse('0.50') == 0.5);</pre><p>Use the toString() method (defined by <a class="ulink" href="http://api.dartlang.org/dart_core/Object.html">Object</a>) to
      convert an int or double to a string. To specify the number of digits to
      the right of the decimal, use toStringAsFixed() (defined by num). To
      specify the number of significant digits in the string, use
      toStringAsPrecision() (also in num).</p><pre class="screen">// Convert an int to a string.
assert(42.toString() == '42');

// Convert a double to a string.
assert(123.456.toString() == '123.456');

// Specify the number of digits after the decimal.
assert(123.456.toStringAsFixed(2) == '123.46');

// Specify the number of significant figures.
assert(123.456.toStringAsPrecision(2) == '1.2e+2');
assert(double.parse('1.2e+2') == 120.0);</pre><p>For more information, see the API documentation for <a class="ulink" href="http://api.dartlang.org/dart_core/int.html">int,</a> <a class="ulink" href="http://api.dartlang.org/dart_core/double.html">double,</a> and
      <a class="ulink" href="http://api.dartlang.org/dart_core/num.html">num</a>.
      Also see <a class="xref" href="ch03.html#ch03-dart-math" title="dart:math - Math and random">dart:math - Math and random</a>.</p></div><div class="sect2" title="Strings and regular expressions"><h3 id="ch03-strings-and-regular-expressions"/>Strings and regular expressions</h3><p>A string in Dart is an immutable sequence of UTF-16 code units.
      The language tour has more information about strings <a class="xref" href="ch02.html#strings" title="Strings">Strings</a>. You can use regular
      expressions (RegExp objects) to search within strings and to replace
      parts of strings.</p><p>The String class defines such methods as split(), contains(),
      startsWith(), endsWith(), and more.</p><div class="sect3" title="Searching inside a string"><h4 id="ch03-searching-inside-a-string"/>Searching inside a string</h4><p>You can find particular locations within a string, as well as
        check whether a string begins with or ends with a particular
        pattern.</p><pre class="screen">// Check whether a string contains another string.
assert('Never odd or even'.contains('odd'));

// Does a string start with another string?
assert('Never odd or even'.startsWith('Never'));

// Does a string end with another string?
assert('Never odd or even'.endsWith('even'));

// Find the location of a string inside a string.
assert('Never odd or even'.indexOf('odd') == 6);</pre></div><div class="sect3" title="Extracting data from a string"><h4 id="ch03-extracting-data-from-a-string"/>Extracting data from a string</h4><p>You can get the individual characters or character codes from
        a string as Strings or ints, respectively.</p><p>You can also extract a substring or split a string into a
        list of substrings.</p><pre class="screen">// Grab a substring.
assert('Never odd or even'.substring(6, 9) == 'odd');

// Split a string using a string pattern.
var parts = 'structured web apps'.split(' ');
assert(parts.length == 3);
assert(parts[0] == 'structured');

// Get the character (as a string) by index.
assert('Never odd or even'[0] == 'N');

// Use splitChars() to get a list of all characters (as Strings);
// good for iterating.
for (var char in 'hello'.splitChars()) {
  print(char);
}

// Get the char code at an index.
assert('Never odd or even'.charCodeAt(0) == 78);

// Get all the char codes as a list of integers.
var charCodes = 'Never odd or even'.charCodes();
assert(charCodes.length == 17);
assert(charCodes[0] == 78);</pre></div><div class="sect3" title="Converting to uppercase or lowercase"><h4 id="ch03-converting-to-uppercase-or-lowercase"/>Converting to uppercase or lowercase</h4><p>You can easily convert strings to their uppercase and
        lowercase variants.</p><pre class="screen">// Convert to uppercase.
assert('structured web apps'.toUpperCase() == 'STRUCTURED WEB APPS');

// Convert to lowercase.
assert('STRUCTURED WEB APPS'.toLowerCase() == 'structured web apps');</pre></div><div class="sect3" title="Trimming and empty strings"><h4 id="ch03-trimming-and-empty-strings"/>Trimming and empty strings</h4><p>Remove all leading and trailing white space with trim(). To
        check whether a string is empty (length is zero), use
        isEmpty().</p><pre class="screen">// Trim a string.
assert('  hello  '.trim() == 'hello');

// Check whether a string is empty.
assert(''.isEmpty());

// Strings with only white space are not empty.
assert(!'  '.isEmpty());</pre></div><div class="sect3" title="Replacing part of a string"><h4 id="_replacing_part_of_a_string"/>Replacing part of a string</h4><p>Strings are immutable objects, which means you can create
        them but you can’t change them. If you look closely at the <a class="ulink" href="http://api.dartlang.org/dart_core/String.html">String API
        docs</a>, you’ll notice that none of the methods actually changes
        the state of a String. For example, the method replaceAll() returns a
        new String without changing the original String.</p><pre class="screen">var greetingTemplate = 'Hello, NAME!';
var greeting = greetingTemplate.replaceAll(new RegExp('NAME'), 'Bob');

assert(greeting != greetingTemplate); // greetingTemplate didn't change.</pre></div><div class="sect3" title="Building a string"><h4 id="_building_a_string"/>Building a string</h4><p>To programmatically generate a string, you can use
        StringBuffer. A StringBuffer doesn’t generate a new String object
        until toString() is called.</p><pre class="screen">var sb = new StringBuffer();

sb.add('Use a StringBuffer ');
sb.addAll(['for ', 'efficient ', 'string ', 'creation ']);
sb.add('if you are ').add('building lots of strings.');

var fullString = sb.toString();

assert(fullString ==
    'Use a StringBuffer for efficient string creation '
    'if you are building lots of strings.');

sb.clear();  // All gone!
assert(sb.toString() == '');</pre></div><div class="sect3" title="Regular expressions"><h4 id="ch03-regular-expressions"/>Regular expressions</h4><p>The RegExp class provides the same capabilities as JavaScript
        regular expressions. Use regular expressions for efficient searching
        and pattern matching of strings.</p><pre class="screen">// A regular expression for one or more digits
var numbers = const RegExp(r'\d+');

var allCharacters = 'llamas live fifteen to twenty years';
var someDigits = 'llamas live 15 to 20 years';

// Contains() can use a regular expression.
assert(!allCharacters.contains(numbers));
assert(someDigits.contains(numbers));

// Replace every match with another string.
var exedOut = someDigits.replaceAll(numbers, 'XX');
assert(exedOut == 'llamas live XX to XX years');</pre><p>You can work directly with the RegExp class, too. The Match
        class provides access to a regular expression match.</p><pre class="screen">var numbers = const RegExp(r'\d+');
var someDigits = 'llamas live 15 to 20 years';

// Check whether the reg exp has a match in a string.
assert(numbers.hasMatch(someDigits));

// Loop through all matches.
for (var match in numbers.allMatches(someDigits)) {
  print(match.group(0)); // 15, then 20
}</pre></div><div class="sect3" title="More information"><h4 id="ch03-more-information-8"/>More information</h4><p>Refer to the <a class="ulink" href="http://api.dartlang.org/dart_core/String.html">String API
        docs</a> for a full list of methods. Also see the API docs for
        <a class="ulink" href="http://api.dartlang.org/dart_core/StringBuffer.html">StringBuffer,</a>
        <a class="ulink" href="http://api.dartlang.org/dart_core/Pattern.html">Pattern,</a>
        <a class="ulink" href="http://api.dartlang.org/dart_core/RegExp.html">RegExp,</a>
        and <a class="ulink" href="http://api.dartlang.org/dart_core/Match.html">Match.</a></p></div></div><div class="sect2" title="Collections"><h3 id="ch03-collections"/>Collections</h3><p>Dart ships with a core collections API, which includes classes
      for lists, sets, and maps.</p><div class="sect3" title="Lists"><h4 id="ch03-lists"/>Lists</h4><p>As the language tour shows <a class="xref" href="ch02.html#lists" title="Lists">Lists</a>, you can use literals to create and
        initialize lists. Alternatively, use one of the List constructors. The
        List class also defines several methods for adding items to and
        removing items from lists.</p><pre class="screen">// Use a List constructor.
var vegetables = new List();

// Or simply use a list literal.
var fruits = ['apples', 'oranges'];

// Add to a list.
fruits.add('kiwis');

// Add multiple items to a list.
fruits.addAll(['grapes', 'bananas']);

// Get the list length.
assert(fruits.length == 5);

// Remove a single item.
var appleIndex = fruits.indexOf('apples');
fruits.removeAt(appleIndex);
assert(fruits.length == 4);

// Remove all elements from a list.
fruits.clear();
assert(fruits.length == 0);</pre><p>Use indexOf() to find the index of an object in a
        list.</p><pre class="screen">var fruits = ['apples', 'oranges'];

// Access a list item by index.
assert(fruits[0] == 'apples');

// Find an item in a list.
assert(fruits.indexOf('apples') == 0);</pre><p>Sort a list using the sort() method. You must provide a
        sorting function that compares two objects. This sorting function must
        return &lt; 0 for <span class="emphasis"><em>smaller</em></span>, 0 for the
        <span class="emphasis"><em>same</em></span>, and &gt; 0 for <span class="emphasis"><em>bigger</em></span>.
        The following example uses compareTo(), which is defined by <a class="ulink" href="http://api.dartlang.org/dart_core/Comparable.html">Comparable</a>
        and implemented by String.</p><pre class="screen">var fruits = ['bananas', 'apples', 'oranges'];

// Sort a list.
fruits.sort((a, b) =&gt; a.compareTo(b));
assert(fruits[0] == 'apples');</pre><p>Lists are parameterized types, so you can specify the type
        that a list should contain.</p><pre class="screen">// This list should contain only strings.
var fruits = new List&lt;String&gt;();

fruits.add('apples');
var fruit = fruits[0];
assert(fruit is String);

// Generates static analysis warning, num is not a string.
fruits.add(5);  // BAD: Throws exception in checked mode.</pre><p>Refer to the <a class="ulink" href="http://api.dartlang.org/dart_core/List.html">List API
        docs</a> for a full list of methods.</p></div><div class="sect3" title="Sets"><h4 id="ch03-sets"/>Sets</h4><p>A set in Dart is an unordered collection of unique items.
        Because a set is unordered, you can’t get a set’s items by index
        (position).</p><pre class="screen">var ingredients = new Set();
ingredients.addAll(['gold', 'titanium', 'xenon']);
assert(ingredients.length == 3);

// Adding a duplicate item has no effect.
ingredients.add('gold');
assert(ingredients.length == 3);

// Remove an item from a set.
ingredients.remove('gold');
assert(ingredients.length == 2);</pre><p>Use contains() and containsAll() to check whether one or more
        objects are in a set.</p><pre class="screen">var ingredients = new Set();
ingredients.addAll(['gold', 'titanium', 'xenon']);

// Check whether an item is in the set.
assert(ingredients.contains('titanium'));

// Check whether all the items are in the set.
assert(ingredients.containsAll(['titanium', 'xenon']));</pre><p>An intersection is a set whose items are in two other sets. A
        subset has all of its items included in another, potentially larger,
        collection.</p><pre class="screen">var ingredients = new Set();
ingredients.addAll(['gold', 'titanium', 'xenon']);

// Create the intersection of two sets.
var nobleGases = new Set.from(['xenon', 'argon']);
var intersection = ingredients.intersection(nobleGases);
assert(intersection.length == 1);
assert(intersection.contains('xenon'));

// Check whether this set is a subset of another collection.
// That is, does another collection contains all the items of this set?
var allElements = ['hydrogen', 'helium', 'lithium', 'beryllium',
                   'gold', 'titanium', 'xenon' /* all the rest */];
assert(ingredients.isSubsetOf(allElements));</pre><p>Refer to the <a class="ulink" href="http://api.dartlang.org/dart_core/Set.html">Set API docs</a>
        for a full list of methods.</p></div><div class="sect3" title="Common collection methods"><h4 id="ch03-common-collection-methods"/>Common collection methods</h4><p>Both List and Set extend the Collection class. As such, they
        share common functionality found in all collections. The following
        examples work with any object that implements Collection.</p><p>Use isEmpty() to check whether a collection has no
        items.</p><pre class="screen">var teas = ['green', 'black', 'chamomile', 'earl grey'];
assert(!teas.isEmpty());</pre><p>To apply a function to each item in a collection, you can use
        forEach(). Or use map() if you want a new collection that contains the
        results.</p><pre class="screen">var teas = ['green', 'black', 'chamomile', 'earl grey'];

teas.forEach((tea) =&gt; print('I drink $tea'));

var loudTeas = teas.map((tea) =&gt; tea.toUpperCase());
assert(loudTeas.some((tea) =&gt; tea == 'GREEN'));</pre><p>Use some() and every() to check whether some or all items in
        a collection match a condition.</p><pre class="screen">var teas = ['green', 'black', 'chamomile', 'earl grey'];

// Chamomile is not caffeinated.
isDecaffeinated(String teaName) =&gt; teaName == 'chamomile';

// Use filter() to create a new collection with only the items
// that return true from the provided function.
var decaffeinatedTeas = teas.filter((tea) =&gt; isDecaffeinated(tea));
// or teas.filter(isDecaffeinated)

// Use some() to check whether at least one item in the collection
// satisfies a condition.
assert(teas.some(isDecaffeinated));

// Use every() to check whether all the items in a collection
// satisfy a condition.
assert(!teas.every(isDecaffeinated));</pre><p>Refer to the <a class="ulink" href="http://api.dartlang.org/dart_core/Collection.html">Collection API
        docs</a> for a full list of methods.</p></div><div class="sect3" title="Maps"><h4 id="ch03-maps-aka-dictionaries-or-hashes"/>Maps</h4><p>A map, commonly known as a <span class="emphasis"><em>dictionary</em></span> or
        <span class="emphasis"><em>hash</em></span>, is an unordered collection of key-value
        pairs. Maps associate a key to some value for easy retrieval. Unlike
        in JavaScript, Dart objects are not maps.</p><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>The Map class does not itself extend Collection. You can,
          however, get a collection of a map’s keys or its values.</div></aside><p>You can declare a map using a terse literal syntax, or you
        can use a traditional constructor.</p><pre class="screen">// Map literals use strings as keys.
var hawaiianBeaches = {
  'oahu' : ['waikiki', 'kailua', 'waimanalo'],
  'big island' : ['wailea bay', 'pololu beach'],
  'kauai' : ['hanalei', 'poipu']
};

// Maps can be built from a constructor.
var searchTerms = new Map();

// Maps are parameterized types; you can specify what types
// the key and value should be.
var nobleGases = new Map&lt;int, String&gt;();</pre><p>You add, get, and set map items using the bracket syntax. Use
        remove() to remove a key and its value from a map.</p><pre class="screen">var nobleGases = new Map&lt;int, String&gt;();

// Maps from constructors can use any object as a key.
// Integers and strings are common key types.
nobleGases[54] = 'xenon';

// Retrieve a value with a key.
assert(nobleGases[54] == 'xenon');

// Check whether a map contains a key.
assert(nobleGases.containsKey(54));

// Remove a key and its value.
nobleGases.remove(54);
assert(!nobleGases.containsKey(54));</pre><p>You can retrieve all the values or all the keys from a
        map.</p><pre class="screen">var hawaiianBeaches = {
  'oahu' : ['waikiki', 'kailua', 'waimanalo'],
  'big island' : ['wailea bay', 'pololu beach'],
  'kauai' : ['hanalei', 'poipu']
};

// Get all the keys as an unordered collection (a list).
var keys = hawaiianBeaches.getKeys();

assert(keys.length == 3);
assert(new Set.from(keys).contains('oahu'));

// Get all the values as an unordered collection (a list of lists).
var values = hawaiianBeaches.getValues();
assert(values.length == 3);
assert(values.some((v) =&gt; v.indexOf('waikiki') != -1));</pre><p>You can also iterate through the key-value pairs.</p><pre class="screen">// NOTE: Do not depend on iteration order.
hawaiianBeaches.forEach((k,v) {
  print('I want to visit $k and swim at $v');
  // I want to visit oahu and swim at [waikiki, kailua, waimanalo], etc.
});</pre><p>To check whether a map contains a key, use containsKey().
        Because map values can be null, you cannot rely on simply getting the
        value for the key and checking for null to determine the existence of
        a key.</p><pre class="screen">var hawaiianBeaches = {
  'oahu' : ['waikiki', 'kailua', 'waimanalo'],
  'big island' : ['wailea bay', 'pololu beach'],
  'kauai' : ['hanalei', 'poipu']
};

assert(hawaiianBeaches.containsKey('oahu'));
assert(!hawaiianBeaches.containsKey('florida'));</pre><p>Use the putIfAbsent() method when you want to assign a value
        to a key if and only if the key does not already exist in a map. You
        must provide a function that returns the value.</p><pre class="screen">var teamAssignments = {};
teamAssignments.putIfAbsent('Catcher', () =&gt; pickToughestKid());
assert(teamAssignments['Catcher'] != null);</pre><p>Refer to the <a class="ulink" href="http://api.dartlang.org/dart_core/Map.html">Map API docs</a>
        for a full list of methods.</p></div></div><div class="sect2" title="Dates and times"><h3 id="ch03-dates-and-times"/>Dates and times</h3><p>A Date object is a point in time. The time zone is either UTC
      or the local time zone.</p><p>You can create Date objects using several
      constructors.</p><pre class="screen">// Get the current date and time.
var now = new Date.now();

// Create a new Date with the local time zone.
var y2k = new Date(2000, 1, 1, 0, 0, 0, 0);

// You can also use named parameters.
y2k = new Date(2000, month: 1, day: 1, hour: 0, minute: 0, second: 0,
               millisecond: 0);

// Specify all the parts of a date as a UTC time.
y2k = new Date(2000, 1, 1, 0, 0, 0, 0, isUtc: true);

// Specify a UTC date and time in milliseconds since the Unix epoch.
y2k = new Date.fromMillisecondsSinceEpoch(946684800000, isUtc: true);

// Parse an ISO 8601 date.
y2k = new Date.fromString('2000-01-01T00:00:00Z');</pre><p>The <code class="literal">millisecondsSinceEpoch</code> property of a
      date returns the number of milliseconds since the epoch.</p><pre class="screen">var y2k = new Date.fromString('2000-01-01T00:00:00Z');
assert(y2k.millisecondsSinceEpoch == 946684800000);</pre><p>Use the Duration class to calculate the difference between two
      dates and to shift a date’s time forward or backwards.</p><pre class="screen">var y2k = new Date.fromString('2000-01-01T00:00:00Z');

// Add one year.
var y2001 = y2k.add(const Duration(days: 366));
assert(y2001.year == 2001);

// Subtract 30 days.
var december2000 = y2001.subtract(const Duration(days: 30));
assert(december2000.year == 2000);
assert(december2000.month == 12);

// Calculate the difference between two dates.
// Returns a Duration object.
var duration = y2001.difference(y2k);
assert(duration.inDays == 366); // y2k was a leap year.</pre><p>Refer to the API docs for <a class="ulink" href="http://api.dartlang.org/dart_core/Date.html">Date</a> and
      <a class="ulink" href="http://api.dartlang.org/dart_core/Duration.html">Duration</a>
      for a full list of methods.</p></div><div class="sect2" title="Utility classes"><h3 id="ch03-utility-interfaces"/>Utility classes</h3><p>The core library contains various utility classes, useful for
      sorting, mapping values, and iterating.</p><div class="sect3" title="Comparing objects"><h4 id="ch03-comparing-objects"/>Comparing objects</h4><p>Implement the <a class="ulink" href="http://api.dartlang.org/dart_core/Comparable.html">Comparable</a>
        interface to indicate that an object can be compared to another
        object, usually for sorting. The compareTo() method returns &lt; 0 for
        <span class="emphasis"><em>smaller</em></span>, 0 for the <span class="emphasis"><em>same</em></span>, and
        &gt; 0 for <span class="emphasis"><em>bigger</em></span>.</p><pre class="screen">class Line implements Comparable {
  final length;
  const Line(this.length);
  int compareTo(Line other) =&gt; length - other.length;
}

main() {
  var short = const Line(1);
  var long = const Line(100);
  assert(short.compareTo(long) &lt; 0);
}</pre></div><div class="sect3" title="Implementing map keys"><h4 id="ch03-implementing-map-keys"/>Implementing map keys</h4><p>Each object in Dart automatically provides an integer hash
        code, and thus can be used as a key in a map. However, you can
        override the hashCode() method to generate a custom hash code. If you
        do, be sure to override the <code class="literal">==</code> operator, as well.
        Objects that are equal (via <code class="literal">==</code>) must have identical
        hash codes. A hash code doesn’t have to be unique, but it should be
        well distributed.</p><pre class="screen">class Person {
  String firstName, lastName;

  Person(this.firstName, this.lastName);

  // Override hashCode using strategy from Effective Java, Chapter 11.
  int hashCode() {
    int result = 17;
    result = 37 * result + firstName.hashCode();
    result = 37 * result + lastName.hashCode();
    return result;
  }

  // Always implement operator== if you override hashCode.
  bool operator==(other) {
    if (identical(other, this)) return true;
    return (other.firstName == firstName &amp;&amp; other.lastName == lastName);
  }
}

main() {
  var p1 = new Person('bob', 'smith');
  var p2 = new Person('bob', 'smith');
  assert(p1.hashCode() == p2.hashCode());
}</pre></div><div class="sect3" title="Iteration"><h4 id="ch03-iteration"/>Iteration</h4><p>The <a class="ulink" href="http://api.dartlang.org/dart_core/Iterable.html">Iterable</a>
        and <a class="ulink" href="http://api.dartlang.org/dart_core/Iterator.html">Iterator</a>
        classes support for-in loops. Implement Iterable to signal that an
        object can provide an Iterator, and thus be used by for-in loops.
        Implement Iterator to define the actual iteration ability.</p><pre class="screen">class Process {
  // Represents a process...
}

class ProcessIterator implements Iterator&lt;Process&gt; {
  Process next() {
    // Return the next process if possible; but if not:
    throw new NoMoreElementsException();
  }
  bool hasNext() {
    // True if calling next() would return a process
    return false;
  }
}

// A mythical class that lets you iterate through all processes.
class Processes implements Iterable&lt;Process&gt; {
  Iterator&lt;Process&gt; iterator() {
    return new ProcessIterator();
  }
}

main() {
  // Objects that implement Iterable can be used with for-in.
  for (var process in new Processes()) {
    // Do something with the process.
  }
}</pre></div></div><div class="sect2" title="Asynchronous programming"><h3 id="ch03-asynchronous-programming"/>Asynchronous programming</h3><p>Asynchronous programming often uses callback functions, but
      Dart provides an alternative: <a class="ulink" href="http://api.dartlang.org/dart_core/Future.html">Future</a>
      objects. A Future is like a promise for a result to be provided sometime
      in the future.</p><p>You have the option of using a <a class="ulink" href="http://api.dartlang.org/dart_core/Completer.html">Completer</a>
      to produce a Future and, later, to supply a value to the
      Future.</p><pre class="screen">Future&lt;bool&gt; longExpensiveSearch() {
  var completer = new Completer();
  // Perform exhaustive search.
  // ...
  // Sometime later,
  // found it!!
  completer.complete(true);
  return completer.future;
}

main() {
  var result = longExpensiveSearch(); // Returns immediately.

  // result.then() returns immediately.
  result.then((success) {
    // The following code executes when the operation is complete.
    print('The item was found: $success');
  });
}</pre><div class="sect3" title="Chaining multiple asynchronous methods"><h4 id="ch03-chaining-multiple-async-methods"/>Chaining multiple asynchronous methods</h4><p>The Future class specifies a chain() method, which is a
        useful way to specify that multiple asynchronous methods run in a
        certain order.</p><pre class="screen">Future result = costlyQuery();
result.handleException((exception) =&gt; print('DOH!'));

result.chain((value) =&gt; expensiveWork())
      .chain((value) =&gt; lengthyComputation())
      .then((value)  =&gt; print('done!'));</pre><p>In the above example, the methods run in the following
        order:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>costlyQuery()</p></li><li class="listitem"><p>expensiveWork()</p></li><li class="listitem"><p>lengthyComputation()</p></li></ol></div></div><div class="sect3" title="Waiting for multiple futures"><h4 id="ch03-waiting-for-multiple-futures"/>Waiting for multiple futures</h4><p>Sometimes your algorithm needs to initiate many asynchronous
        methods and wait for each one to complete before continuing. Use the
        <a class="ulink" href="http://api.dartlang.org/dart_core/Futures.html">Futures</a>
        class to manage multiple Futures and wait for them all to
        complete.</p><pre class="screen">Future deleteDone = deleteLotsOfFiles();
Future copyDone = copyLotsOfFiles();
Future checksumDone = checksumLotsOfOtherFiles();

Futures.wait([deleteDone, copyDone, checksumDone]).then((List values) {
  print('Done with all the long steps');
});</pre></div><div class="sect3" title="More information"><h4 id="ch03-more-information-9"/>More information</h4><p>For examples of using Future, see <a class="xref" href="ch03.html#ch03-dartio---file-and-socket-io-for-command-line-apps" title="dart:io - I/O for command-line apps">dart:io - I/O for command-line apps</a>.</p></div></div><div class="sect2" title="Exceptions"><h3 id="ch03-exceptions"/>Exceptions</h3><p>The Dart core library defines many common exceptions and
      errors. Exceptions are considered conditions that you can plan ahead for
      and catch. Errors are conditions that you don’t expect or plan
      for.</p><p>Some of the most common exceptions and errors
      include:</p><div class="variablelist"><dl><dt><span class="term">
            <a class="ulink" href="http://api.dartlang.org/dart_core/NoSuchMethodError.html">NoSuchMethodError</a>
          </span></dt><dd><p>Thrown when a receiving object does not implement a
            method.</p></dd><dt><span class="term">
            <a class="ulink" href="http://api.dartlang.org/dart_core/NullPointerException.html">NullPointerException</a>
          </span></dt><dd><p>Thrown when the program tries to call a method or access
            a field of a null object.</p></dd><dt><span class="term">
            <a class="ulink" href="http://api.dartlang.org/dart_core/ArgumentError.html">ArgumentError</a>
          </span></dt><dd><p>Can be thrown by a method that encounters an unexpected
            argument.</p></dd></dl></div><p>Throwing an application-specific exception is a common way to
      indicate that an error has occurred. You can define a custom exception
      by implementing the Exception interface.</p><pre class="screen">class FooException implements Exception {
  final String msg;
  const FooException([this.msg]);
  String toString() =&gt; msg == null ? 'FooException' : msg;
}</pre><p>For more information, see <a class="xref" href="ch02.html#exceptions" title="Exceptions">Exceptions</a> and the
      <a class="ulink" href="http://api.dartlang.org/dart_core/Exception.html">Exception
      API docs.</a></p></div></div><div class="sect1" title="dart:math - Math and random"><h2 id="ch03-dart-math"/>dart:math - Math and random</h2><p>The Math library provides common functionality such as sine and
    cosine, maximum and minimum, and constants such as <span class="emphasis"><em>pi</em></span>
    and <span class="emphasis"><em>e</em></span>. Most of the functionality in the Math library
    is implemented as top-level functions.</p><p>To use the Math library in your app, import
    <code class="literal">dart:math</code>. The following examples use the prefix
    <code class="literal">Math</code> to make clear which top-level functions and
    constants are from the Math library.</p><pre class="screen">import 'dart:math' as math;</pre><div class="sect2" title="Trigonometry"><h3 id="ch03-trigonometry"/>Trigonometry</h3><p>The Math library provides basic trigonometric
      functions.</p><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>These methods use radians, not degrees!</div></aside><pre class="screen">// Cosine
assert(math.cos(math.PI) == -1.0);

// Sine
var degrees = 30;
var radians = degrees * (math.PI / 180);
// radians is now 0.52359.
var sinOf30degrees = math.sin(radians);

// Truncate the decimal places to 2.
assert(double.parse(sinOf30degrees.toStringAsPrecision(2)) == 0.5);</pre></div><div class="sect2" title="Maximum and mininum"><h3 id="ch03-maximum-and-mininum"/>Maximum and mininum</h3><p>The Math library provides optimized max() and min()
      methods.</p><pre class="screen">assert(math.max(1, 1000) == 1000);
assert(math.min(1, -1000) == -1000);</pre></div><div class="sect2" title="Math constants"><h3 id="ch03-math-constants"/>Math constants</h3><p>Find your favorite constants—<span class="emphasis"><em>pi</em></span>,
      <span class="emphasis"><em>e</em></span>, and more—in the Math library.</p><pre class="screen">// See the Math library for additional constants.
print(math.E);     // 2.718281828459045
print(math.PI);    // 3.141592653589793
print(math.SQRT2); // 1.4142135623730951</pre></div><div class="sect2" title="Random numbers"><h3 id="ch03-random-numbers"/>Random numbers</h3><p>Generate random numbers with the <a class="ulink" href="http://api.dartlang.org/dart_math/Random.html">Random</a>
      class. You can optionally provide a seed to the Random
      constructor.</p><pre class="screen">var random = new math.Random();
random.nextDouble(); // Between 0.0 and 1.0: [0, 1)
random.nextInt(10);  // Between 0 and 9.</pre><p>You can even generate random booleans.</p><pre class="screen">var random = new math.Random();
random.nextBool();  // true or false</pre></div><div class="sect2" title="More information"><h3 id="ch03-more-information-7"/>More information</h3><p>Refer to the <a class="ulink" href="http://api.dartlang.org/dart_math/index.html">Math API docs</a>
      for a full list of methods. Also see the API docs for <a class="ulink" href="http://api.dartlang.org/dart_core/num.html">num,</a> <a class="ulink" href="http://api.dartlang.org/dart_core/int.html">int,</a> and <a class="ulink" href="http://api.dartlang.org/dart_core/double.html">double.</a></p></div></div><div class="sect1" title="dart:html - Browser-based apps"><h2 id="ch03-dart-html-using-html5-apis"/>dart:html - Browser-based apps</h2><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>Only web apps can use dart:html, not command-line
      apps.</div></aside><p>Use the <a class="ulink" href="http://api.dartlang.org/dart_html.html">dart:html library</a> to
    program the browser, manipulate objects and elements in the DOM, and
    access HTML5 APIs. <em class="firstterm">DOM</em> stands for
    <span class="emphasis"><em>Document Object Model</em></span>, which describes the hierarchy
    of an HTML page.</p><p>Other common uses of dart:html are manipulating styles
    (<span class="emphasis"><em>CSS</em></span>), getting data using HTTP requests, and
    exchanging data using WebSockets <a class="xref" href="ch03.html#ch03-websockets" title="Sending and receiving real-time data with WebSockets">Sending and receiving real-time data with WebSockets</a>.</p><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>HTML5 (and dart:html) has many additional APIs that this
      section doesn’t cover.</div></aside><p>To use the HTML library in your web app, import
    <code class="literal">dart:html</code>.</p><pre class="programlisting">import 'dart:html';</pre><div class="sect2" title="Manipulating the DOM"><h3 id="ch03-manipulating-the-dom"/>Manipulating the DOM</h3><p>To use the DOM, you need to know about
      <span class="emphasis"><em>windows</em></span>, <span class="emphasis"><em>documents</em></span>,
      <span class="emphasis"><em>elements</em></span>, and <span class="emphasis"><em>nodes</em></span>.</p><p>A <a class="ulink" href="http://api.dartlang.org/html/Window.html">Window</a> object
      represents the actual window of the web browser. Each Window has a
      <code class="literal">document</code> property (a Document object), which points
      to the document currently loaded. The Window object also has accessors
      to various APIs such as IndexedDB (for storing data),
      requestAnimationFrame() (for animations), and more. In tabbed browsers,
      each tab has its own Window object.</p><p>With the <a class="ulink" href="http://api.dartlang.org/html/Document.html"> Document</a>
      object, you can create and manipulate <a class="ulink" href="http://api.dartlang.org/html/Element.html">Elements</a> within
      the document. Note that the document itself is an element and can be
      manipulated.</p><p>The DOM models a tree of <a class="ulink" href="http://api.dartlang.org/html/Node.html">Nodes.</a> These nodes
      are often elements, but they can also be attributes, text, comments, and
      other DOM types. Except for the root node, which has no parent, each
      node in the DOM has one parent and might have many children.</p><div class="sect3" title="Finding elements"><h4 id="ch03-finding-elements"/>Finding elements</h4><p>To manipulate an element, you first need an object that
        represents it. You can get this object using a query.</p><p>Find one or more elements using the top-level functions
        query() and queryAll(). You can query by ID, class, tag, name, or any
        combination of these. The <a class="ulink" href="http://www.w3.org/TR/css3-selectors/">CSS Selector
        Specification</a> guide defines the formats of the selectors such
        as using a # prefix to specify IDs and a period (.) for
        classes.</p><p>The query() function returns the first element that matches
        the selector, while queryAll() returns a collection of elements that
        match the selector.</p><pre class="screen">Element elem1 = query('#an-id');           // Find an element by id (an-id).
Element elem2 = query('.a-class');         // Find an element by class (a-class).
List&lt;Element&gt; elems1 = queryAll('div');    // Find all elements by tag (&lt;div&gt;).
List&lt;Element&gt; elems2 = queryAll('input[type="text"]'); // Find all text inputs.

// Find all elements with the CSS class 'class' inside of a &lt;p&gt;
// that is inside an element with the ID 'id'.
List&lt;Element&gt; elems3 = queryAll('#id p .class');</pre></div><div class="sect3" title="Manipulating elements"><h4 id="ch03-manipulating-elements"/>Manipulating elements</h4><p>You can use properties to change the state of an element.
        Node and its subtype Element define the properties that all elements
        have. For example, all elements have <code class="literal">classes</code>,
        <code class="literal">hidden</code>, <code class="literal">id</code>,
        <code class="literal">innerHTML</code>, <code class="literal">style</code>,
        <code class="literal">text</code>, and <code class="literal">title</code> properties.
        Subclasses of Element define additional properties, such as the
        <code class="literal">href</code> property of <a class="ulink" href="http://api.dartlang.org/html/AnchorElement.html">AnchorElement.</a></p><p>Consider this example of specifying an anchor element in
        HTML:</p><pre class="screen">&lt;a id='example' href='http://example.com'&gt;linktext&lt;/a&gt;</pre><p>This &lt;a&gt; tag specifies an element with an
        <code class="literal">href</code> attribute and a text node (accessible via a
        <code class="literal">text</code> property) that contains the string “linktext”.
        To change the URL that the link goes to, you can use AnchorElement’s
        <code class="literal">href</code> property:</p><pre class="screen">query('#example').href = 'http://dartlang.org';</pre><p>Often you need to set properties on multiple elements. For
        example, the following code sets the <code class="literal">hidden</code>
        property of all elements that have a class of “mac”, “win”, or
        “linux”. Setting the <code class="literal">hidden</code> property to true has
        the same effect as adding <code class="literal">display:none</code> to the
        CSS.</p><pre class="screen">&lt;!-- Some HTML --&gt;
&lt;p&gt;
  &lt;a href="/downloads/linux" class="os linux"&gt;Download for Linux&lt;/a&gt;
  &lt;a href="/downloads/mac" class="os mac"&gt;Download for Mac&lt;/a&gt;
  &lt;a href="/downloads/win" class="os win"&gt;Download for Windows&lt;/a&gt;
&lt;/p&gt;

// Some Dart.

final osList = ['mac', 'win', 'linux'];

main() {
  var userOs = determineUserOs();

  for (var os in osList) {            // For each possible OS...
    bool shouldShow = (os == userOs); // Does this OS match the user's OS?
    for (var elem in queryAll('.$os')) { // Find all elements for this OS.
      elem.hidden = !shouldShow;      // Show or hide each element.
    }
  }
}</pre><p>When the right property isn’t available or convenient, you
        can use Element’s <code class="literal">attributes</code> property. This
        property has the type <a class="ulink" href="http://api.dartlang.org/html/AttributeMap.html">AttributeMap,</a>
        which implements a map <a class="xref" href="ch03.html#ch03-maps-aka-dictionaries-or-hashes" title="Maps">Maps</a> with keys that are strings (attribute
        names) and values that it automatically converts to strings. For a
        list of attribute names and their meanings, see the <a class="ulink" href="https://developer.mozilla.org/en/HTML/Attributes"> MDN Attributes
        page.</a> Here’s an example of setting an attribute’s
        value.</p><pre class="screen">elem.attributes['someAttribute'] = 'someValue';</pre></div><div class="sect3" title="Creating elements"><h4 id="ch03-creating-elements"/>Creating elements</h4><p>You can add to existing HTML pages by creating new elements
        and attaching them to the DOM. Here’s an example of creating a
        paragraph (&lt;p&gt;) element:</p><pre class="screen">var elem = new ParagraphElement();
elem.text = 'Creating is easy!';</pre><p>You can also create an element by parsing HTML text. Any
        child elements are also parsed and created.</p><pre class="screen">var elem = new Element.html('&lt;p&gt;Creating &lt;em&gt;is&lt;/em&gt; easy!&lt;/p&gt;');</pre><p>Note that elem is a ParagraphElement in the above
        example.</p><p>Attach the newly created element to the document by assigning
        a parent to the element. You can add an element to any existing
        element’s children. In the following example, <code class="literal">body</code>
        is an element, and its child elements are accessible (as a
        List&lt;Element&gt;) from the <code class="literal">elements</code>
        property.</p><pre class="screen">var elem = new ParagraphElement();
elem.text = "Don't forget to feed the llamas!";
document.body.elements.add(elem);</pre></div><div class="sect3" title="Adding, replacing, and removing nodes"><h4 id="ch03-adding-replacing-and-removing-nodes"/>Adding, replacing, and removing nodes</h4><p>Recall that elements are just a kind of node. You can find
        all the children of a node using the <code class="literal">nodes</code> property
        of Node, which returns a List&lt;Node&gt;. Once you have this list,
        you can use the usual List methods and operators to manipulate the
        children of the node.</p><p>To add a node as the last child of its parent, use the List
        add() method.</p><pre class="screen">// Find the parent by ID, and add elem as its last child.
query('#inputs').nodes.add(elem);</pre><p>To replace a node, use the Node replaceWith()
        method.</p><pre class="screen">// Find a node by ID, and replace it in the DOM.
query('#status').replaceWith(elem);</pre><p>To remove a node, use the Node remove() method.</p><pre class="screen">// Find a node by ID, and remove it from the DOM.
query('#example').remove();</pre></div><div class="sect3" title="Manipulating CSS styles"><h4 id="ch03-manipulating-styles"/>Manipulating CSS styles</h4><p>CSS, or <span class="emphasis"><em>cascading style sheets</em></span>, is used
        to define the presentation styles of DOM elements. You can change the
        appearance of an element by attaching ID and class attributes to
        it.</p><p>Each element has a <code class="literal">classes</code> field, which is
        a list. Add and remove CSS classes simply by adding and removing
        strings from this collection. For example, the following sample adds
        the <code class="literal">warning</code> class to an element.</p><pre class="screen">var element = query('#message');
element.classes.add('warning');</pre><p>It’s often very efficient to find an element by ID. You can
        dynamically set an element ID with the <code class="literal">id</code>
        property.</p><pre class="screen">var message = new DivElement();
message.id = 'message';
message.text = 'Please subscribe to the Dart mailing list.';</pre><p>You can reduce the redundant text in this example by using
        method cascades:</p><pre class="screen">var message = new DivElement()
    ..id = 'message'
    ..text = 'Please subscribe to the Dart mailing list.';</pre><p>While using IDs and classes to associate an element with a
        set of styles is best practice, sometimes you want to attach a
        specific style directly to the element.</p><pre class="screen">message.style
    ..fontWeight = 'bold'
    ..fontSize = '3em';</pre></div><div class="sect3" title="Handling events"><h4 id="ch03-handling-events"/>Handling events</h4><p>To respond to external events such as clicks, changes of
        focus, and selections, add an event listener. You can add an event
        listener to any element on the page. Event dispatch and propagation is
        a complicated subject; <a class="ulink" href="http://www.w3.org/TR/DOM-Level-3-Events/#dom-event- architecture">research
        the details</a> if you’re new to web programming.</p><p>Add an event handler using
        <code class="literal">element.on.<em class="replaceable"><code>event</code></em>.add(<em class="replaceable"><code>function</code></em>)</code>,
        where <code class="literal"><em class="replaceable"><code>event</code></em></code> is the event
        name and <code class="literal"><em class="replaceable"><code>function</code></em></code> is the
        event handler.</p><p>For example, here’s how you can handle clicks on a
        button.</p><pre class="screen">// Find a button by ID and add an event handler.
query('#submitInfo').on.click.add((e) {
  // When the button is clicked, it runs this code.
  submitData();
});</pre><p>Events can propagate up and down through the DOM tree. To
        discover which element originally fired the event, use
        <code class="literal">e.target</code>.</p><pre class="screen">document.body.on.click.add((e) {
  var clickedElem = e.target;
  print('You clicked the ${clickedElem.id} element.');
});</pre><p>To see all the events for which you can register an event
        listener, consult the API docs for <a class="ulink" href="http://api.dartlang.org/html/ElementEvents.html">ElementEvents</a>
        and its subclasses. Some common events include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>change</p></li><li class="listitem"><p>blur</p></li><li class="listitem"><p>keyDown</p></li><li class="listitem"><p>keyUp</p></li><li class="listitem"><p>mouseDown</p></li><li class="listitem"><p>mouseUp</p></li></ul></div></div></div><div class="sect2" title="Using HTTP resources with HttpRequest"><h3 id="ch03-httprequest"/>Using HTTP resources with HttpRequest</h3><p>Formerly known as XMLHttpRequest, the <span class="emphasis"><em><a class="ulink" href="http://api.dartlang.org/dart_html/HttpRequest.html">HttpRequest</a></em></span>
      class gives you access to HTTP resources from within your browser-based
      app. Traditionally, AJAX-style apps make heavy use of HttpRequest. Use
      HttpRequest to dynamically load JSON data or any other resource from a
      web server. You can also dynamically send data to a web
      server.</p><p>The following examples assume all resources are served from the
      same web server that hosts the script itself. Due to security
      restrictions in the browser, the HttpRequest class can’t easily use
      resources that are hosted on an origin that is different from the origin
      of the app. If you need to access resources that live on a different web
      server, you need to either use a technique called JSONP or enable CORS
      headers on the remote resources.</p><div class="sect3" title="Getting data from the server"><h4 id="_getting_data_from_the_server"/>Getting data from the server</h4><p>The <code class="literal">HttpRequest.get()</code> constructor is an
        easy way to get data from a web server.</p><pre class="screen">import 'dart:html';
import 'dart:json';

onSuccess(HttpRequest request) {
  Map response = JSON.parse(request.responseText);
  String name = response['name'];
  String license = response['license'];
  print('The $name project uses the $license license.');
}

main() {
  // Request the data at 'data.json', a file in the same location as this page.
  var httpRequest = new HttpRequest.get('data.json', onSuccess);
}</pre><p>The onSuccess() function runs when the data at the specified
        URI is successfully retrieved. In this case, we are dynamically
        loading a JSON file, whose contents are delivered in
        <code class="literal">request.responseText</code>. Information about the JSON
        API is in <a class="xref" href="ch03.html#ch03-json" title="dart:json - Encoding and decoding objects">dart:json - Encoding and decoding objects</a>.</p><p>The <code class="literal">HttpRequest.get()</code> constructor is great
        for simple cases, but you can also use the full API to handle more
        interesting cases. For example, you can capture errors and set
        arbitrary headers.</p><p>The general flow for using the full API of HttpRequest is as
        follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Create the HttpRequest object.</p></li><li class="listitem"><p>Open the URL with either <code class="literal">GET</code> or
            <code class="literal">POST</code>.</p></li><li class="listitem"><p>Attach event handlers.</p></li><li class="listitem"><p>Send the request.</p></li></ol></div><p>A full example of handling errors follows:</p><pre class="screen">import 'dart:html';
import 'dart:json';

loadEnd(HttpRequest request) {
  if (request.status != 200) {
    print('Uh oh, there was an error of ${request.status}');
    return;
  }

  Map response = JSON.parse(request.responseText);
  String name = response['name'];
  String license = response['license'];
  print('The $name project uses the $license license.');
}

main() {
  var dataUrl = 'data.json';
  var httpRequest = new HttpRequest();
  httpRequest.open('GET', dataUrl);
  httpRequest.on.loadEnd.add((e) =&gt; loadEnd(httpRequest));
  httpRequest.send();
}</pre></div><div class="sect3" title="Sending data to the server"><h4 id="_sending_data_to_the_server"/>Sending data to the server</h4><p>HttpRequest can also send data to the server, using the HTTP
        method POST. For example, you might want to dynamically submit data to
        a form handler. Sending JSON data to a RESTful web service is another
        common example.</p><p>Submitting data to a form handler requires you to provide
        name-value pairs as URI-encoded strings. (Information about the URI
        API is in <a class="xref" href="ch03.html#ch03-uri" title="dart:uri - Manipulating URIs">dart:uri - Manipulating URIs</a>.) You must also set the
        <code class="literal">Content-type</code> header to
        <code class="literal">application/x-www-form-urlencode</code> if you wish to
        send data to a form handler.</p><pre class="screen">import 'dart:html';
import 'dart:json';
import 'dart:uri';

String encodeMap(Map data) {
  return Strings.join(data.getKeys().map((k) {
    return '${encodeUriComponent(k)}=${encodeUriComponent(data[k])}';
  }), '&amp;');
}

loadEnd(HttpRequest request) {
  if (request.status != 200) {
    print('Uh oh, there was an error of ${request.status}');
    return;
  } else {
    print('Data has been posted');
  }
}

main() {
  var dataUrl = '/registrations/create';
  var data = {'dart': 'fun', 'editor': 'productive'};
  var encodedData = encodeMap(data);

  var httpRequest = new HttpRequest();
  httpRequest.open('POST', dataUrl);
  httpRequest.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
  httpRequest.on.loadEnd.add((e) =&gt; loadEnd(httpRequest));
  httpRequest.send(encodedData);
}</pre></div></div><div class="sect2" title="Sending and receiving real-time data with WebSockets"><h3 id="ch03-websockets"/>Sending and receiving real-time data with WebSockets</h3><p>A WebSocket allows your web app to exchange data with a server
      interactively—no polling necessary. A server creates the WebSocket and
      listens for requests on a URL that starts with <span class="strong"><strong>ws://</strong></span>—for example, ws://127.0.0.1:1337/ws. The
      data transmitted over a WebSocket can be a string, a blob, or an <a class="ulink" href="http://api.dartlang.org/html/ArrayBuffer.html">ArrayBuffer.</a>
      Often, the data is a JSON-formatted string.</p><p>To use a WebSocket in your web app, first create a <a class="ulink" href="http://api.dartlang.org/html/WebSocket.html">WebSocket</a>
      object, passing the WebSocket URL as an argument.</p><pre class="screen">var webSocket = new WebSocket('ws://127.0.0.1:1337/ws');</pre><div class="sect3" title="Sending data"><h4 id="ch03-sending-data"/>Sending data</h4><p>To send string data on the WebSocket, use the send()
        method.</p><pre class="screen">sendMessage(String data) {
  if (webSocket.readyState == WebSocket.OPEN) {
    webSocket.send(data);
  } else {
    throw 'WebSocket not connected, message $data not sent';
  }
}</pre></div><div class="sect3" title="Receiving data"><h4 id="ch03-receiving-data"/>Receiving data</h4><p>To receive data on the WebSocket, register a listener for
        message events.</p><pre class="screen">webSocket.on.message.add((e) {
  receivedMessage((e as MessageEvent).data);
});</pre><p>The message event handler receives a <a class="ulink" href="http://api.dartlang.org/html/MessageEvent.html">MessageEvent</a>
        object. This object’s <code class="literal">data</code> field has the data from
        the server. Here’s an example of decoding a JSON string sent on a
        WebSocket, where the JSON string has two fields, “from” and
        “content”.</p><pre class="screen">// Called from the message listener like this: receivedMessage(e.data)
receivedMessage(String data) {
  Map message = JSON.parse(data);
  if (message['from'] != null) {
    print('Message from ${message['from']}: ${message['content']}');
  }
}</pre></div><div class="sect3" title="Handling WebSocket events"><h4 id="ch03-handling-websocket-events"/>Handling WebSocket events</h4><p><a class="ulink" href="http://api.dartlang.org/html/WebSocketEvents.html">WebSocketEvents</a>
        defines the WebSocket events your app can handle: open, close, error,
        and (as shown above) message. Here’s an example of a method that
        creates a WebSocket object and handles message, open, close, and error
        events.</p><pre class="screen">connectToWebSocket([int retrySeconds = 2]) {
  bool reconnectScheduled = false;
  webSocket = new WebSocket(url);
  
  scheduleReconnect() {
    print('web socket closed, retrying in $retrySeconds seconds');
    if (!reconnectScheduled) {
      window.setTimeout(() =&gt; connectToWebSocket(retrySeconds*2), 1000*retrySeconds);
    }
    reconnectScheduled = true;
  }
  
  webSocket.on.open.add((e) {
    print('Connected');
  });
  
  webSocket.on.close.add((e) =&gt; scheduleReconnect());
  webSocket.on.error.add((e) =&gt; scheduleReconnect());
  
  webSocket.on.message.add((MessageEvent e) {
    _receivedEncodedMessage(e.data);
  });
}</pre><p>For an example of using WebSockets, see <a class="xref" href="ch05.html" title="Chapter 5. Walkthrough: Dart Chat">Chapter 5</a>.</p></div></div></div><div class="sect1" title="dart:isolate - Concurrency with isolates"><h2 id="ch03-dartisolate---concurrency-with-isolates"/>dart:isolate - Concurrency with isolates</h2><p>Dart has no shared-memory threads. Instead, all Dart code runs in
    isolates, which communicate via message passing. Messages are copied
    before they are received, ensuring that no two isolates can manipulate the
    same object instance. Because state is managed by individual isolates, no
    locks or mutexes are needed, greatly simplifying concurrent
    programming.</p><div class="sect2" title="Isolate concepts"><h3 id="ch03-isolate-concepts"/>Isolate concepts</h3><p>To use isolates, you should understand the following
      concepts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>No two isolates ever share the same thread at the same
          time. Within an isolate, callbacks execute one at a time, making the
          code more predictable.</p></li><li class="listitem"><p>All values in memory, including globals, are available only
          to their isolate. No isolate can see or manipulate values owned by
          another isolate.</p></li><li class="listitem"><p>The only way isolates can communicate with each other is by
          passing messages.</p></li><li class="listitem"><p>Isolates send messages using SendPorts, and receive them
          using ReceivePorts.</p></li><li class="listitem"><p>The content of a message can be any of the
          following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A primitive value (null, num, bool, double,
              String)</p></li><li class="listitem"><p>An instance of SendPort</p></li><li class="listitem"><p>A list or map whose elements are any of the above,
              including other lists and maps</p></li><li class="listitem"><p>In special circumstances <a class="xref" href="ch03.html#ch03-sending-any-type-of-object" title="Sending any type of object">Sending any type of object</a>, an object of any type</p></li></ul></div></li><li class="listitem"><p>Each isolate has a ReceivePort, which is available as the
          <code class="literal">port</code> variable. Because all Dart code runs inside
          an isolate, even main() has access to a port object.</p></li><li class="listitem"><p>When a web application is compiled to JavaScript, its
          isolates can be implemented as Web workers. When running in Dartium,
          isolates run in the VM.</p></li><li class="listitem"><p>In the standalone VM, the main() function runs in the first
          isolate (also known as the <span class="emphasis"><em>root isolate</em></span>). When
          the root isolate terminates, it terminates the whole VM, regardless
          of whether other isolates are still running. For more information,
          see <a class="xref" href="ch03.html#ch03-keeping-the-root-isolate-alive" title="Keeping the root isolate alive">Keeping the root isolate alive</a>.</p></li></ul></div></div><div class="sect2" title="Using isolates"><h3 id="ch03-using-isolates"/>Using isolates</h3><p>To use an isolate, you import the
      <code class="literal">dart:isolate</code> library, spawn a new isolate, and then
      send and receive messages.</p><div class="sect3" title="Spawning isolates"><h4 id="ch03-spawning-isolates"/>Spawning isolates</h4><p>Any top-level function or static method<sup>[<a id="id630190" href="#ftn.id630190" class="footnote">2</a>]</sup> is a valid entry point for an isolate. The entry point
        should not expect arguments and should return void. It is illegal to
        use a function closure as an entry point to an isolate. Pass the entry
        point to spawnFunction().</p><pre class="screen">import 'dart:isolate';

runInIsolate() {
  print('hello from an isolate!');
}

main() {
  spawnFunction(runInIsolate);

  // Note: incomplete.
  // Use a ReceivePort (details below) to keep the root isolate alive
  // long enough for runInIsolate() to perform its work.
}</pre><p>We plan to support spawning an isolate from code at a
        URI.</p></div><div class="sect3" title="Sending messages"><h4 id="ch03-sending-messages"/>Sending messages</h4><p>Send a message to an isolate via a SendPort. The
        spawnFunction() method returns a handle to the newly created isolate’s
        SendPort.</p><p>To simply send a message, use send().</p><pre class="screen">import 'dart:isolate';

echo() {
  // Receive messages here. (See the next section.)
}

main() {
  var sendPort = spawnFunction(echo);
  sendPort.send('Hello from main');

  // Note: incomplete.
  // Use a ReceivePort (details below) to keep the root isolate alive
  // long enough for echo() to perform its work.
}</pre></div><div class="sect3" title="Sending any type of object"><h4 id="ch03-sending-any-type-of-object"/>Sending any type of object</h4><p>In special circumstances (such as when using spawnFunction()
        inside the Dart VM), it is possible to send any type of object to an
        isolate.<sup>[<a id="id637180" href="#ftn.id637180" class="footnote">3</a>]</sup> The object message is copied when sent.</p></div><div class="sect3" title="Receiving messages"><h4 id="ch03-receiving-messages"/>Receiving messages</h4><p>Use a ReceivePort to receive messages sent to an isolate.
        Obtain a handle to the default ReceivePort from the top-level
        <code class="literal">port</code> property. You can also create new instances of
        ReceivePort, if you want to route messages to different ports and
        callbacks.</p><p>Handle an incoming message with a callback function passed to
        the receive() method.</p><pre class="screen">import 'dart:isolate';

echo() {
  port.receive((msg, reply) {
    print('I received: $msg');
  });
}

main() {
  var sendPort = spawnFunction(echo);
  sendPort.send('Hello from main');

  // Note: incomplete.
  // Use a ReceivePort (details below) to keep the root isolate alive
  // long enough for echo() to perform its work.
}</pre></div><div class="sect3" title="Receiving replies"><h4 id="ch03-receiving-replies"/>Receiving replies</h4><p>Use the call() method on SendPort as a simple way to send a
        message and receive a reply. The call() method returns a Future for
        the reply.</p><pre class="screen">import 'dart:isolate';

echo() {
  port.receive((msg, reply) {
    reply.send('I received: $msg');
  });
}

main() {
  var sendPort = spawnFunction(echo);
  sendPort.call('Hello from main').then((reply) {
    print(reply);    // I received: Hello from main
  });
}</pre><p>Under the covers, the call() method creates and manages a
        SendPort and a ReceivePort, which are necessary for a
        call-and-response message exchange.</p></div><div class="sect3" title="Keeping the root isolate alive"><h4 id="ch03-keeping-the-root-isolate-alive"/>Keeping the root isolate alive</h4><p>In the VM, an isolate continues to run as long as it has an
        open ReceivePort inside the isolate. If the main() function only
        starts other isolates, doing no work itself, you must keep the root
        isolate alive to keep the program alive.</p><p>To keep a root isolate alive, open a ReceivePort in the root
        isolate. When all the child isolates have finished their work, you can
        send a message to the root isolate to close its ReceivePort, thus
        stopping the program.</p><p>You can coordinate isolates with message passing, sending a
        message to inform the root isolate when a child isolate finishes. Here
        is an example:</p><pre class="screen">import 'dart:isolate';

childIsolate() {
  port.receive((msg, replyTo) {
    print('doing some work');
    if (replyTo != null) replyTo.send('shutdown');
  });
}

main() {
  var sender = spawnFunction(childIsolate);
  var receiver = new ReceivePort();
  receiver.receive((msg, _) {
    if (msg == 'shutdown') {
      print('shutting down');
      receiver.close();
    }
  });
  sender.send('do work please', receiver.toSendPort());
}</pre><p>In the above example, the child isolate runs to completion
        because the root isolate keeps a ReceivePort open. The root isolate
        creates a ReceivePort to wait for a shutdown message. The term
        shutdown is arbitrary; the ReceivePort simply needs to wait for some
        signal.</p><p>Once the root isolate receives a shutdown message, it closes
        the ReceivePort. With the ReceivePort closed and nothing else to do,
        the root isolate terminates, causing the app to exit.</p></div></div><div class="sect2" title="More information"><h3 id="ch03-more-information-11"/>More information</h3><p>See the API docs for the <a class="ulink" href="http://api.dartlang.org/dart_isolate.html">dart:isolate
      library,</a> as well as for <a class="ulink" href="http://api.dartlang.org/dart_isolate/SendPort.html">SendPort</a>
      and <a class="ulink" href="http://api.dartlang.org/dart_isolate/ReceivePort.html">ReceivePort.</a></p></div></div><div class="sect1" title="dart:io - I/O for command-line apps"><h2 id="ch03-dartio---file-and-socket-io-for-command-line-apps"/>dart:io - I/O for command-line apps</h2><p>The <a class="ulink" href="http://api.dartlang.org/io.html">dart:io
    library</a> provides APIs to deal with files, directories, processes,
    sockets, and HTTP connections. Only command-line apps can use dart:io—not
    web apps.</p><p>In general, the dart:io library implements and promotes an
    asynchronous API. Synchronous methods can easily block the event loop,
    making it difficult to scale server applications. Therefore, most
    operations return results via callbacks or Future objects, a pattern
    common with modern server platforms such as Node.js.</p><p>The few synchronous methods in the dart:io library are clearly
    marked with a Sync suffix on the method name. We don’t cover them
    here.</p><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>Only command-line apps can import and use
      <code class="literal">dart:io</code>.</div></aside><div class="sect2" title="Files and directories"><h3 id="ch03-files-and-directories"/>Files and directories</h3><p>The I/O library enables command-line apps to read and write
      files and browse directories. You have two choices for reading the
      contents of a file: all at once, or streaming. Reading a file all at
      once requires enough memory to store all the contents of the file. If
      the file is very large or you want to process it while reading it, you
      should use an InputStream, as described in <a class="xref" href="ch03.html#ch03-streaming-file-contents" title="Streaming file contents">Streaming file contents</a>.</p><div class="sect3" title="Reading a file as text"><h4 id="ch03-reading-a-file-as-text"/>Reading a file as text</h4><p>When reading a text file, you can read the entire file
        contents with readAsText(). When the individual lines are important,
        you can use readAsLines(). In both cases, a Future object is returned
        that provides the contents of the file as one or more
        strings.</p><pre class="screen">import 'dart:io';

main() {
  var config = new File('config.txt');

  // Put the whole file in a single string.
  config.readAsText(Encoding.UTF_8).then((String contents) {
    print('The entire file is ${contents.length} characters long');
  });

  // Put each line of the file into its own string.
  config.readAsLines(Encoding.UTF_8).then((List&lt;String&gt; lines) {
    print('The entire file is ${lines.length} lines long');
  });
}</pre></div><div class="sect3" title="Reading a file as binary"><h4 id="ch03-reading-a-file-as-binary"/>Reading a file as binary</h4><p>The following code reads an entire file as bytes into a list
        of ints. The call to readAsBytes() returns a Future, which provides
        the result when it’s available.</p><pre class="screen">import 'dart:io';

main() {
  var config = new File('config.txt');

  config.readAsBytes().then((List&lt;int&gt; contents) {
    print('The entire file is ${contents.length} bytes long');
  });
}</pre></div><div class="sect3" title="Handling errors"><h4 id="ch03-handling-errors"/>Handling errors</h4><p>Errors are thrown as exceptions if you do not register an
        explicit handler. If you want to capture an error, you can register a
        <code class="literal">handleException</code> handler with the Future
        object.</p><pre class="screen">import 'dart:io';

main() {
  var config = new File('config.txt');
  Future readFile = config.readAsText();
  readFile.handleException((e) {
    print(e);
    // ...Other error handling goes here...
    return true; // We've handled the exception; no need to propagate it.
  });
  readFile.then((text) =&gt; print(text));
}</pre></div><div class="sect3" title="Streaming file contents"><h4 id="ch03-streaming-file-contents"/>Streaming file contents</h4><p>Use an InputStream to read a file, a little at a time. The
        <code class="literal">onData</code> callback runs when data is ready to be read.
        When the InputStream is finished reading the file, the
        <code class="literal">onClosed</code> callback executes.</p><pre class="screen">import 'dart:io';

main() {
  var config = new File('config.txt');
  var inputStream = config.openInputStream();

  inputStream.onError = (e) =&gt; print(e);
  inputStream.onClosed = () =&gt; print('file is now closed');
  inputStream.onData = () {
    List&lt;int&gt; bytes = inputStream.read();
    print('Read ${bytes.length} bytes from stream');
  };
}</pre><p>To decode an input stream from bytes into characters, wrap
        the InputStream with a <a class="ulink" href="http://api.dartlang.org/io/StringInputStream.html">StringInputStream</a>.
        You can read the strings either as data becomes available or a line at
        a time.</p></div><div class="sect3" title="Writing file contents"><h4 id="ch03-writing-file-contents"/>Writing file contents</h4><p>Use an OutputStream to write data to a file. Open a file for
        writing with openOutputStream() and declare a mode. Use
        <code class="literal">FileMode.WRITE</code> to completely overwrite existing
        data in the file, and <code class="literal">FileMode.APPEND</code> to add to the
        end.</p><pre class="screen">import 'dart:io';

main() {
  var logFile = new File('log.txt');
  var out = logFile.openOutputStream(FileMode.WRITE);
  out.writeString('FILE ACCESSED ${new Date.now()}');
  out.close();
}</pre><p>To write binary data, use <code class="literal">write(List&lt;int&gt;
        buffer)</code>.</p></div><div class="sect3" title="Listing files in a directory"><h4 id="ch03-listing-files-in-a-directory"/>Listing files in a directory</h4><p>Finding all files and subdirectories for a directory is an
        asynchronous operation. The list() method returns a DirectoryLister,
        on which you can register callback handlers to be notified when a file
        is encountered (using <code class="literal">onFile</code>) or when a directory
        is encountered (using <code class="literal">onDir</code>).</p><pre class="screen">import 'dart:io';

main() {
  var dir = new Directory('/tmp');

  DirectoryLister lister = dir.list(recursive:true); // Returns immediately.
  lister.onError = (e) =&gt; print(e);
  lister.onFile = (String name) =&gt; print('Found file $name');
  lister.onDir = (String name) =&gt; print('Found dir $name');
}</pre></div><div class="sect3" title="Other common functionality"><h4 id="ch03-other-common-functionality"/>Other common functionality</h4><p>The File and Directory classes contain other functionality,
        including but not limited to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Creating a file or directory: create() in File and
            Directory</p></li><li class="listitem"><p>Deleting a file or directory: delete() in File and
            Directory</p></li><li class="listitem"><p>Getting the length of a file: length() in File</p></li><li class="listitem"><p>Getting random access to a file: open() in File</p></li></ul></div><p>Refer to the API docs for <a class="ulink" href="http://api.dartlang.org/io/File.html">File,</a> <a class="ulink" href="http://api.dartlang.org/io/Directory.html">Directory,</a> and
        <a class="ulink" href="http://api.dartlang.org/io/DirectoryLister.html">DirectoryLister</a>
        for a full list of methods. Also see <a class="ulink" href="http://api.dartlang.org/io/InputStream.html">InputStream</a>,
        <a class="ulink" href="http://api.dartlang.org/io/StringInputStream.html">StringInputStream</a>,
        and <a class="ulink" href="http://api.dartlang.org/io/OutputStream.html">OutputStream.</a></p><p>Besides the APIs discussed in this section, the dart:io
        library also provides APIs for <a class="ulink" href="http://api.dartlang.org/io/Process.html">processes</a>,
        <a class="ulink" href="http://api.dartlang.org/io/Socket.html">sockets</a>,
        and <a class="ulink" href="http://api.dartlang.org/io/WebSocket.html">web
        sockets</a>.</p><p>For more examples of using dart:io, see <a class="xref" href="ch05.html" title="Chapter 5. Walkthrough: Dart Chat">Chapter 5</a>.</p></div></div><div class="sect2" title="HTTP clients and servers"><h3 id="ch03-io-http"/>HTTP clients and servers</h3><p>The dart:io library provides classes that command-line apps can
      use for accessing HTTP resources, as well as running HTTP
      servers.</p><div class="sect3" title="HTTP server"><h4 id="_http_server"/>HTTP server</h4><p>The <a class="ulink" href="http://api.dartlang.org/dart_io/HttpServer.html">HttpServer</a>
        class provides the low-level functionality for building web servers.
        You can match request handlers, set headers, stream data, and
        more.</p><p>Because Dart is single threaded and has an event loop, the
        API design of HttpServer favors callbacks for handling
        events.</p><p>The following sample web server can return only simple text
        information. This server listens on port 8888 and address 127.0.0.1
        (localhost), responding to requests for the path
        <code class="literal">/languages/dart</code>. All other requests are handled by
        the default request handler, which returns a response code of 404 (not
        found).</p><pre class="screen">import 'dart:io';

main() {
  dartHandler(HttpRequest request, HttpResponse response) {
    print('New request');
    response.outputStream.writeString('Dart is optionally typed');
    response.outputStream.close();
  };

  var httpServer = new HttpServer();
  httpServer.addRequestHandler(
      (req) =&gt; req.path == '/languages/dart',
      dartHandler);

  httpServer.listen('127.0.0.1', 8888);
}</pre><p>You can see a more comprehensive HTTP server in <a class="xref" href="ch05.html#ch05-server" title="The server’s code">The server’s code</a>.</p></div><div class="sect3" title="HTTP client"><h4 id="_http_client"/>HTTP client</h4><p>The <a class="ulink" href="http://api.dartlang.org/dart_io/HttpClient.html">HttpClient</a>
        class helps you connect to HTTP resources from your Dart command-line
        or server-side application. You can set headers, use HTTP methods, and
        read and write data.</p><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>The HttpClient class does not work in browser-based apps.
          When programming in the browser, use the HttpRequest class <a class="xref" href="ch03.html#ch03-httprequest" title="Using HTTP resources with HttpRequest">Using HTTP resources with HttpRequest</a>.</div></aside><p>The HttpClient API, like the HttpServer API, is callback
        oriented. The general flow of events is as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Create a new HttpClient.</p></li><li class="listitem"><p>Get the URL.</p></li><li class="listitem"><p>Register the onResponse() callback on the
            HttpClientConnection.</p></li><li class="listitem"><p>Register the onData() callback on the input
            stream.</p></li><li class="listitem"><p>Register the onClosed() callback on the
            HttpClientConnection.</p></li><li class="listitem"><p>Read data when available.</p></li><li class="listitem"><p>Shut down the HttpClient when you no longer want to
            create connections using it.</p></li></ol></div><pre class="screen">import 'dart:io';
import 'dart:uri';

main() {
  var httpClient = new HttpClient();
  var conn = httpClient.getUrl(new Uri('http://127.0.0.1:8888/languages/dart'));
  conn.onResponse = (HttpClientResponse resp) {
    var input = resp.inputStream;
    input.onData = () {
      var data = input.read();
      var text = new String.fromCharCodes(data);
      print(text);
    };
    input.onClosed = () =&gt; httpClient.shutdown();
  };
}</pre></div></div></div><div class="sect1" title="dart:json - Encoding and decoding objects"><h2 id="ch03-json"/>dart:json - Encoding and decoding objects</h2><p><a class="ulink" href="http://www.json.org/">JSON</a> is a simple text
    format for representing structured objects and collections. The <a class="ulink" href="http://api.dartlang.org/json.html">JSON library</a> decodes
    JSON-formatted strings into Dart objects, and encodes objects into
    JSON-formatted strings.</p><p>The Dart JSON library works in both web apps and command-line
    apps. To use the JSON library, import
    <code class="literal">dart:json</code>.</p><div class="sect2" title="Decoding JSON"><h3 id="ch03-json-decoding"/>Decoding JSON</h3><p>Decode a JSON-encoded string into a Dart object with
      JSON.parse().</p><pre class="screen">import 'dart:json';

main() {
  // NOTE: Be sure to use double quotes ("), not single quotes ('),
  // inside the JSON string. This string is JSON, not Dart.
  var jsonString = '''
  [
    {"score": 40},
    {"score": 80}
  ]
  ''';

  var scores = JSON.parse(jsonString);
  assert(scores is List);

  var firstScore = scores[0];
  assert(firstScore is Map);
  assert(firstScore['score'] == 40);
}</pre></div><div class="sect2" title="Encoding JSON"><h3 id="ch03-json-encoding"/>Encoding JSON</h3><p>Encode a supported Dart object into a JSON-formatted string
      with JSON.stringify().</p><p>Only objects of type int, double, String, bool, null, List, or
      Map can be encoded into JSON. List and Map objects are encoded
      recursively.</p><p>If any object that isn’t an int, double, String, bool, null,
      List, or Map is passed to stringify(), the object’s toJson() method is
      called. If toJson() returns an encodable value, that value is encoded in
      the object’s place.</p><pre class="screen">import 'dart:json';

main() {
  var scores = [
    {'score': 40},
    {'score': 80},
    {'score': 100, 'overtime': true, 'special_guest': null}
  ];

  var jsonText = JSON.stringify(scores);
  assert(jsonText == '[{"score":40},{"score":80},'
                     '{"score":100,"overtime":true,'
                     '"special_guest":null}]');
}</pre></div></div><div class="sect1" title="dart:uri - Manipulating URIs"><h2 id="ch03-uri"/>dart:uri - Manipulating URIs</h2><p>The <a class="ulink" href="http://api.dartlang.org/uri.html">URI
    library</a> provides functions to encode and decode strings for use in
    URIs (which you might know as <span class="emphasis"><em>URLs</em></span>). These functions
    handle characters that are special for URIs, such as
    <code class="literal">&amp;</code> and <code class="literal">=</code>.</p><p>Another part of the URI library is the Uri class, which parses
    and exposes the components of a URI—domain, port, scheme, and so
    on.</p><p>The URI library works in both web apps and command-line apps. To
    use it, import <code class="literal">dart:uri</code>.</p><div class="sect2" title="Encoding and decoding fully qualified URIs"><h3 id="ch03-uri-fully-qualified"/>Encoding and decoding fully qualified URIs</h3><p>To encode and decode characters <span class="emphasis"><em>except</em></span>
      those with special meaning in a URI (such as <code class="literal">/</code>,
      <code class="literal">:</code>, <code class="literal">&amp;</code>, <code class="literal">#</code>),
      use the top-level encodeUri() and decodeUri() functions. These functions
      are good for encoding or decoding a fully qualified URI, leaving intact
      special URI characters.</p><pre class="screen">import 'dart:uri';

main() {
  var uri = 'http://example.org/api?foo=some message';
  var encoded = encodeUri(uri);
  assert(encoded == 'http://example.org/api?foo=some%20message');

  var decoded = decodeUri(encoded);
  assert(uri == decoded);
}</pre><p>Notice how only the space between <code class="literal">some</code> and
      <code class="literal">message</code> was encoded.</p></div><div class="sect2" title="Encoding and decoding URI components"><h3 id="ch03-uri-components"/>Encoding and decoding URI components</h3><p>To encode and decode all of a string’s characters that have
      special meaning in a URI, including (but not limited to)
      <code class="literal">/</code>, <code class="literal">&amp;</code>, and
      <code class="literal">:</code>, use the top-level encodeUriComponent() and
      decodeUriComponent() functions.</p><pre class="screen">import 'dart:uri';

main() {
  var uri = 'http://example.org/api?foo=some message';
  var encoded = encodeUriComponent(uri);
  assert(encoded == 'http%3A%2F%2Fexample.org%2Fapi%3Ffoo%3Dsome%20message');

  var decoded = decodeUriComponent(encoded);
  assert(uri == decoded);
}</pre><p>Notice how every special character is encoded. For example,
      <code class="literal">/</code> is encoded to <code class="literal">%2F</code>.</p></div><div class="sect2" title="Parsing URIs"><h3 id="ch03-uri-parsing"/>Parsing URIs</h3><p>You can parse a URI into its parts with the Uri()
      constructor.</p><pre class="screen">import 'dart:uri';

main() {
  var uri = new Uri('http://example.org:8080/foo/bar#frag');

  assert(uri.scheme == 'http');
  assert(uri.domain == 'example.org');
  assert(uri.path == '/foo/bar');
  assert(uri.fragment == 'frag');
  assert(uri.origin == 'http://example.org:8080');
}</pre><p>See the <a class="ulink" href="http://api.dartlang.org/uri/Uri.html">Uri
      API docs</a> for more URI components that you can get.</p></div><div class="sect2" title="Building URIs"><h3 id="ch03-uri-building"/>Building URIs</h3><p>You can build up a URI from individual parts using the
      Uri.fromComponents() constructor.</p><pre class="screen">import 'dart:uri';

main() {
  var uri = new Uri.fromComponents(scheme: 'http', domain: 'example.org', path: '/foo/bar',
                                   fragment: 'frag');
  assert(uri.toString() == 'http://example.org/foo/bar#frag');
}</pre></div></div><div class="sect1" title="dart:utf - Strings and Unicode"><h2 id="ch03-utf"/>dart:utf - Strings and Unicode</h2><p>The UTF library helps bridge the gap between strings and
    UTF-8/UTF-16/UTF-32 encodings.</p><p>The UTF library works in both web apps and command-line apps. To
    use the UTF library, import <code class="literal">dart:utf</code>.</p><div class="sect2" title="Decoding UTF-8 characters"><h3 id="ch03-utf-decode-utf8"/>Decoding UTF-8 characters</h3><p>Use decodeUtf8() to decode UTF8-encoded bytes to a Dart
      string.</p><pre class="screen">import 'dart:utf';

main() {
  var string = decodeUtf8([0xc3, 0x8e, 0xc3, 0xb1, 0xc5, 0xa3, 0xc3, 0xa9,
                           0x72, 0xc3, 0xb1, 0xc3, 0xa5, 0xc5, 0xa3, 0xc3,
                           0xae, 0xc3, 0xb6, 0xc3, 0xb1, 0xc3, 0xa5, 0xc4,
                           0xbc, 0xc3, 0xae, 0xc5, 0xbe, 0xc3, 0xa5, 0xc5,
                           0xa3, 0xc3, 0xae, 0xe1, 0xbb, 0x9d, 0xc3, 0xb1]);
  print(string); // 'Îñţérñåţîöñåļîžåţîờñ'
}</pre></div><div class="sect2" title="Encoding strings to UTF-8 bytes"><h3 id="ch03-utf-encode-utf8"/>Encoding strings to UTF-8 bytes</h3><p>Use encodeUtf8() to encode a Dart string as a list of
      UTF8-encoded bytes.</p><pre class="screen">import 'dart:utf';

main() {
  List&lt;int&gt; expected = [0xc3, 0x8e, 0xc3, 0xb1, 0xc5, 0xa3, 0xc3, 0xa9, 0x72,
                        0xc3, 0xb1, 0xc3, 0xa5, 0xc5, 0xa3, 0xc3, 0xae, 0xc3,
                        0xb6, 0xc3, 0xb1, 0xc3, 0xa5, 0xc4, 0xbc, 0xc3, 0xae,
                        0xc5, 0xbe, 0xc3, 0xa5, 0xc5, 0xa3, 0xc3, 0xae, 0xe1,
                        0xbb, 0x9d, 0xc3, 0xb1];

  List&lt;int&gt; encoded = encodeUtf8('Îñţérñåţîöñåļîžåţîờñ');

  assert(() {
    if (encoded.length != expected.length) return false;
    for (int i = 0; i &lt; encoded.length; i++) {
      if (encoded[i] != expected[i]) return false;
    }
    return true;
  });
}</pre></div><div class="sect2" title="Other functionality"><h3 id="ch03-utf-other"/>Other functionality</h3><p>The UTF library can decode and encode UTF-16 and UTF-32 bytes.
      For details, see the <a class="ulink" href="http://api.dartlang.org/utf.html">API docs for the UTF
      library.</a></p></div></div><div class="sect1" title="dart:crypto - Hash codes and more"><h2 id="ch03-crypto"/>dart:crypto - Hash codes and more</h2><p>The <a class="ulink" href="http://api.dartlang.org/crypto.html">Dart crypto
    library</a> contains functions useful for cryptographic applications,
    such as creating cryptographic hashes and generating hash-based message
    authentication codes.</p><p>The crypto library works in both web apps and command-line apps.
    To use the crypto library, import
    <code class="literal">dart:crypto</code>.</p><div class="sect2" title="Generating cryptographic hashes"><h3 id="ch03-crypto-hash"/>Generating cryptographic hashes</h3><p>With the crypto library, you can use <a class="ulink" href="http://api.dartlang.org/crypto/SHA256.html">SHA256,</a> <a class="ulink" href="http://api.dartlang.org/crypto/SHA1.html">SHA1,</a> or <a class="ulink" href="http://api.dartlang.org/crypto/MD5.html">MD5</a> objects to
      generate hashes (also known as <span class="emphasis"><em>digests</em></span> or
      <span class="emphasis"><em>message digests</em></span>). We recommend using SHA256, but we
      have included SHA1 and MD5 for compatibility with older systems. All
      these types inherit from <a class="ulink" href="http://api.dartlang.org/crypto/Hash.html">Hash,</a> which
      defines the Dart interface for <a class="ulink" href="http://en.wikipedia.org/wiki/Cryptographic_hash_function">cryptographic
      hash functions.</a></p><pre class="screen">import 'dart:crypto';

main() {
  var sha256 = new SHA256();
  var digest = sha256.update('message'.charCodes()).digest();
  var hexString = CryptoUtils.bytesToHex(digest);
  assert(hexString ==
      'ab530a13e45914982b79f9b7e3fba994cfd1f3fb22f71cea1afbf02b460c6d1d');
}</pre><p>If the message content changes, the digest value also changes
      (with a very high probability).</p></div><div class="sect2" title="Generating message authentication codes"><h3 id="ch03-crypto-authentication"/>Generating message authentication codes</h3><p>Use a hash-based message authentication code (<a class="ulink" href="http://en.wikipedia.org/wiki/HMAC">HMAC</a>) to combine a
      cryptographic hash function with a secret key.</p><pre class="screen">import 'dart:crypto';
main() {
  var hmac = new HMAC(new SHA256(), 'secretkey'.charCodes());
  var hmacDigest = hmac.update('message'.charCodes()).digest();
  var hmacHex = CryptoUtils.bytesToHex(hmacDigest);
  assert(hmacHex ==
      '5c3e2f56de9411068f675ef32ffa12735210b9cbfee2ba521367a3955334a343');
}</pre><p>If either the message contents or key changes, the digest value
      also changes (with a very high probability).</p></div><div class="sect2" title="Generating Base64 strings"><h3 id="ch03-crypto-base64"/>Generating Base64 strings</h3><p>You can represent binary data as a character string by using
      the <a class="ulink" href="http://en.wikipedia.org/wiki/Base64">Base64</a>
      encoding scheme. Use the CryptoUtils.bytesToBase64() utility method to
      convert a list of bytes into a Base64-encoded string.</p><pre class="screen">import 'dart:crypto';
import 'dart:io';

main() {
  var file = new File('icon.ico');
  var bytes = file.readAsBytesSync();
  var base64 = CryptoUtils.bytesToBase64(bytes);
  assert(base64 ==
    'iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38G'
    'IAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==');
}</pre></div></div><div class="sect1" title="Summary"><h2 id="id638348"/>Summary</h2><p>This chapter introduced you to the most commonly used functionality
    in Dart’s built-in libraries. You can use the pub tool, discussed in the
    next chapter, to install additional Dart libraries.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.id630190" href="#id630190" class="para">2</a>] </sup>The dart2js compiler and the Dart VM do not yet support
            static methods as isolate entry points. For details, see <a class="ulink" href="http://dartbug.com/3011">http://dartbug.com/3011</a>.</p></div><div class="footnote"><p><sup>[<a id="ftn.id637180" href="#id637180" class="para">3</a>] </sup>Support for sending an arbitrary object to an isolate is not
            yet available when compiling to JavaScript.</p></div>
