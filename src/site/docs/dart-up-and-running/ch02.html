---
layout: book
title: "Chapter 2. A Tour of the Dart Language"
description: "Learn how to use each major Dart language feature."
js:
- url: /js/lang-tour-analytics.js
  defer: true
---

<h1 id="a-tour-of-the-dart-language"> {{ page.title }} </h1>

<p>This chapter shows you how to use each major Dart feature, from
  variables and operators to classes and libraries, with the assumption that
  you already know how to program in another language.</p>

<aside class="note" title="Tip">
  <div class="alert alert-info">
<strong>Tip:</strong>
  To play with each feature, create a server application project in
    Dart Editor, as described in <a class="xref" href="ch01.html#ch01-editor" title="Up and running">Up and running</a>.</div></aside>

<p>Consult the <a class="ulink" href="http://www.dartlang.org/docs/spec/">Dart
  Language Specification</a> whenever you want more details about a
  language feature.</p>

<section>
<h4 id="TOC"> Contents </h4>
  <ol class="toc">
    <li><a href="#a-basic-dart-program">A basic Dart program</a></li>
    <li><a href="#important-concepts">Important concepts</a></li>
    <li><a href="#variables">Variables</a></li>
    <li><a href="#built-in-types">Built-in types</a></li>
    <li><a href="#functions">Functions</a></li>
    <li><a href="#operators">Operators</a></li>
    <li><a href="#control-flow-statements">Control flow statements</a></li>
    <li><a href="#exceptions">Exceptions</a></li>
    <li><a href="#classes">Classes</a></li>
    <li><a href="#generics">Generics</a></li>
    <li><a href="#libraries-and-visibility">Libraries and visibility</a></li>
    <li><a href="#isolates">Isolates</a></li>
    <li><a href="#typedefs">Typedefs</a></li>
    <li><a href="#comments">Comments</a></li>
    <li><a href="#summary">Summary</a></li>
  </ol>
</section>

  <div class="sect1" title="A basic Dart program"><h2 id="a-basic-dart-program"/>A basic Dart program</h2><p>The following code uses many of Dart’s most basic features.</p><pre class="programlisting">// Define a function.
printNumber(num aNumber) {
  print('The number is $aNumber.'); // Print to the console.
}

// This is where the app starts executing.
main() {
  var number = 42;           // Declare and initialize a variable.
  printNumber(number);       // Call a function.
}</pre><p>Here’s what this program uses that applies to all (or almost all)
    Dart apps:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">// <em class="replaceable">This is a comment.</em></code></span></dt><dd><p>Use // to indicate that the rest of the line is a comment.
          Alternatively, use /* ... */. For details, see <a class="xref" href="ch02.html#comments" title="Comments">Comments</a>.</p></dd><dt><span class="term"><code class="literal">num</code></span></dt><dd><p>A type. Some of the other built-in types are String, int, and
          bool.</p></dd><dt><span class="term"><code class="literal">100</code></span></dt><dd><p>A number <em class="firstterm">literal</em>. Literals are a kind
          of compile-time constant.</p></dd><dt><span class="term"><code class="literal">print()</code></span></dt><dd><p>A handy way to display output.</p></dd><dt><span class="term"><code class="literal">'...'</code> (or <code class="literal">"..."</code>)</span></dt><dd><p>A string literal.</p></dd><dt><span class="term"><code class="literal">$<em class="replaceable">variableName</em></code> (or
        <code class="literal">${<em class="replaceable">expression</em>}</code>)</span></dt><dd><p>String interpolation: including a variable or expression’s
          string equivalent inside of a string literal. For more information,
          see <a class="xref" href="ch02.html#strings" title="Strings">Strings</a>.</p></dd><dt><span class="term"><code class="literal">main()</code></span></dt><dd><p>The special, <span class="emphasis"><em>required</em></span>, top-level function
          where app execution starts.</p></dd><dt><span class="term"><code class="literal">var</code></span></dt><dd><p>A way to declare a variable without specifying its
          type.</p></dd></dl></div><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>Our code follows the conventions in the <a class="ulink" href="http://www.dartlang.org/articles/style-guide/">Dart Style
      Guide.</a> For example, we use two-space indentation.</div></aside><div class="sect1" title="Important concepts"><h2 id="important-concepts"/>Important concepts</h2><p>As you learn about the Dart language, keep these facts and concepts
    in mind:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Everything you can place in a variable is an
        <span class="emphasis"><em>object</em></span>, and every object is an instance of a
        <span class="emphasis"><em>class</em></span>. Even numbers and functions are objects.
        All objects inherit from the <a class="ulink" href="http://api.dartlang.org/dart_core/Object.html">Object</a>
        class.</p></li><li class="listitem"><p>Specifying static types (such as <code class="literal">num</code> in the preceding example) clarifies your
        intent and enables static checking by tools, but it’s optional. (You
        might notice when you’re debugging your code that objects with no
        specified type get a special type: <code class="literal">dynamic</code>.)</p></li><li class="listitem"><p>Dart parses all your code before running it. You can provide
        tips to Dart—for example, by using types or compile-time constants—to
        catch errors or help your code run faster.</p></li><li class="listitem"><p>Dart supports top-level functions (such as main()), as well as
        functions tied to a class or object (<span class="emphasis"><em>static</em></span> and
        <span class="emphasis"><em>instance methods</em></span>, respectively).</p></li><li class="listitem"><p>Similarly, Dart supports top-level
        <span class="emphasis"><em>variables</em></span>, as well as variables tied to a class
        or object (static and instance variables). Instance variables are
        sometimes known as <em class="firstterm">fields</em> or
        <em class="firstterm">properties</em>.</p></li><li class="listitem"><p>Unlike Java, Dart doesn’t have the keywords <code class="literal">public</code>, <code class="literal">protected</code>, and <code class="literal">private</code>. If an identifier starts with an
        underscore (_), it’s private to its library. For details, see <a class="xref" href="ch02.html#libraries-and-visibility" title="Libraries and visibility">Libraries and visibility</a>.</p></li><li class="listitem"><p><em class="firstterm">Identifiers</em> can start with a letter or _,
        followed by any combination of those characters plus digits.</p></li><li class="listitem"><p>Sometimes it matters whether something is an
        <span class="emphasis"><em>expression</em></span> or a <span class="emphasis"><em>statement</em></span>,
        so we’ll be precise about those two words.</p></li><li class="listitem"><p>Dart tools can report two kinds of errors: warnings and errors.
        Warnings are just hints that your code might not work, but they don’t
        prevent your program from executing. Errors can be either compile-time
        or run-time. A compile-time error prevents the code from executing at
        all; a run-time error results in an exception <a class="xref" href="ch02.html#exceptions" title="Exceptions">Exceptions</a> being raised while the code executes.</p></li><li class="listitem"><p>Dart has two <em class="firstterm">runtime modes</em>: production
        and checked. Production is faster, but checked is helpful at
        development.</p></li></ul></div><div class="sect2" title="Runtime modes"><h3 id="ch02-runtime-modes"/>Runtime modes</h3><p>We recommend that you develop and debug in checked mode, and
      deploy to production mode.</p><p><span class="emphasis"><em>Production mode</em></span> is the default runtime mode
      of a Dart program, optimized for speed. Production mode ignores assert
      statements <a class="xref" href="ch02.html#assert" title="Assert">Assert</a> and static types.</p><p><span class="emphasis"><em>Checked mode</em></span> is a developer-friendly mode
      that helps you catch some type errors during runtime. For example, if
      you assign a non-number to a variable declared as a <code class="literal">num</code>, then checked mode throws an
      exception.</p><div class="sect1" title="Variables"><h2 id="variables"/>Variables</h2><p>Here’s an example of creating a variable and assigning a value to
    it:</p><pre class="programlisting">var name = 'Bob';</pre><p>Variables are references. The variable called <code class="literal">name</code> contains a reference to a String object
    with a value of <span class="quote">“<span class="quote">Bob</span>”</span>.</p><div class="sect2" title="Default value"><h3 id="variables-default-value"/>Default value</h3><p>Uninitialized variables have an initial value of <code class="literal">null</code>. Even variables with numeric types are
      initially null, because numbers are objects.</p><pre class="programlisting">int lineCount;
assert(lineCount == null); // Variables (even if they will be numbers) are initially null.</pre><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>The assert() call is ignored in production mode. In checked
        mode, <code class="literal">assert(<em class="replaceable"><code>condition</code></em>)</code>
        throws an exception unless <em class="replaceable"><code>condition</code></em> is
        true. For details, see <a class="xref" href="ch02.html#assert" title="Assert">Assert</a>.</div></aside><div class="sect2" title="Optional types"><h3 id="variables-optional-types"/>Optional types</h3><p>You have the option of adding static types to your variable
      declarations:</p><pre class="programlisting">String name = 'Bob';</pre><p>Adding types is a way to clearly express your intent. Tools such
      as compilers and editors can use these types to help you, by providing
      early warnings for bugs and code completion.</p><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>This chapter follows the <a class="ulink" href="http://www.dartlang.org/articles/style-guide/#type-annotations">style
        guide recommendation</a> of using <code class="literal">var</code>, rather than type annotations, for local
        variables.</div></aside><div class="sect2" title="Final and const"><h3 id="id554927"/>Final and const</h3><p>If you never intend to change a variable, use <code class="literal">final</code> or <code class="literal">const</code>, either instead of <code class="literal">var</code> or in addition to a type. A final variable
      can be set only once; a const variable is a compile-time
      constant.</p><p>A local, top-level, or class variable that’s declared as <code class="literal">final</code> is initialized the first time it’s
      used.</p><pre class="programlisting">final name = 'Bob';   // Or: final String name = 'Bob';
// name = 'Alice';    // Uncommenting this results in an error</pre><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>Lazy initialization of final variables helps apps start up
        faster.</p></div><p>Use <code class="literal">const</code> for variables that
      you want to be compile-time constants. Where you declare the variable,
      set the value to a compile-time constant such as a literal, a const
      variable, or the result of an arithmetic operation on constant
      numbers.</p><pre class="programlisting">const bar = 1000000;       // Unit of pressure (in dynes/cm2)
const atm = 1.01325 * bar; // Standard atmosphere</pre></div><div class="sect1" title="Built-in types"><h2 id="built-in-types"/>Built-in types</h2><p>The Dart language has special support for the following
    types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>numbers</p></li><li class="listitem"><p>strings</p></li><li class="listitem"><p>booleans</p></li><li class="listitem"><p>lists (also known as <span class="emphasis"><em>arrays</em></span>)</p></li><li class="listitem"><p>maps</p></li></ul></div><p>You can initialize an object of any of these special types using a
    literal. For example, <code class="literal">'this is a
    string'</code> is a string literal, and <code class="literal">true</code> is a boolean literal.</p><p>Because every variable in Dart refers to an object—an instance of a
    <span class="emphasis"><em>class</em></span>—you can usually use
    <span class="emphasis"><em>constructors</em></span> to initialize variables. Some of the
    built-in types have their own constructors. For example, you can use the
    Map() constructor to create a map, using code such as <code class="literal">new Map()</code>.</p><div class="sect2" title="Numbers"><h3 id="numbers"/>Numbers</h3><p>Dart numbers come in two flavors:</p><div class="variablelist"><dl><dt><span class="term"><a class="ulink" href="http://api.dartlang.org/dart_core/int.html">
          <code class="literal">int</code> </a></span></dt><dd><p>Integers of arbitrary size</p></dd><dt><span class="term"><a class="ulink" href="http://api.dartlang.org/dart_core/double.html">
          <code class="literal">double</code> </a></span></dt><dd><p>64-bit (double-precision) floating-point numbers, as
            specified by the IEEE 754 standard</p></dd></dl></div><p>Both <code class="literal">int</code> and <code class="literal">double</code> are subtypes of <a class="ulink" href="http://api.dartlang.org/dart_core/num.html"><code class="literal">num</code>.</a> The num type includes basic
      operators such as +, -, /, and *, as well as bitwise operators such as
      &gt;&gt;. The num type is also where you’ll find abs(), ceil(), and
      floor(), among other methods. If num and its subtypes don’t have what
      you’re looking for, the <a class="ulink" href="http://api.dartlang.org/dart_core/Math.html">Math</a> class
      might.</p><p>Integers are numbers without a decimal point. Here are some
      examples of defining integer literals:</p><pre class="programlisting">var x = 1;
var hex = 0xDEADBEEF;
var bigInt = 346534658346524376592384765923749587398457294759347029438709349347;</pre><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>In JavaScript produced from Dart code, big integers currently
        behave differently than they do when the same Dart code runs in the
        Dart VM. For details, see <a class="ulink" href="http://dartbug.com/1533">http://dartbug.com/1533</a>.</p></div><p>If a number includes a decimal, it is a double. Here are some
      examples of defining double literals:</p><pre class="programlisting">var y = 1.1;
var exponents = 1.42e5;</pre><p>Here’s how you turn a string into a number, or vice versa:</p><pre class="programlisting">// String -&gt; int
var one = int.parse('1');
assert(one == 1);

// String -&gt; double
var onePointOne = double.parse('1.1');
assert(onePointOne == 1.1);

// int -&gt; String
String oneAsString = 1.toString();
assert(oneAsString == '1');

// double -&gt; String
String piAsString = 3.14159.toStringAsFixed(2);
assert(piAsString == '3.14');</pre><p>The num type specifies the traditional bitwise shift (&lt;&lt;,
      &gt;&gt;), AND (&amp;), and OR (|) operators. For example:</p><pre class="programlisting">assert((3 &lt;&lt; 1) == 6);  // 0011 &lt;&lt; 1 == 0110
assert((3 &gt;&gt; 1) == 1);  // 0011 &gt;&gt; 1 == 0001
assert((3 | 4)  == 7);  // 0011 | 0100 == 0111</pre></div><div class="sect2" title="Strings"><h3 id="strings"/>Strings</h3><p>A Dart string is a sequence of UTF-16 code units. You can use
      either single or double quotes to create a string:</p><pre class="programlisting">var s1 = 'Single quotes work well for string literals.';
var s2 = "Double quotes work just as well.";
var s3 = 'It\'s easy to escape the string delimiter.';
var s4 = "It's even easier to just use the other string delimiter.";</pre><p>You can put the value of an expression inside a string by using
      ${<span class="emphasis"><em>expression</em></span>}. If the expression is an identifier,
      you can skip the {}. To get the string corresponding to an object, Dart
      calls the object’s toString() method.</p><pre class="programlisting">var s = 'string interpolation';

assert('Dart has $s, which is very handy.' ==
       'Dart has string interpolation, which is very handy.');
assert('That deserves all caps. ${s.toUpperCase()} is very handy!' ==
       'That deserves all caps. STRING INTERPOLATION is very handy!');</pre><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>The <code class="literal">==</code> operator tests whether
        two objects are equivalent. Two strings are equivalent if they have
        the same characters.</p></div><p>You can concatenate strings using adjacent string literals:</p><pre class="programlisting">var s = 'String ''concatenation'
        " works even over line breaks.";
assert(s == 'String concatenation works even over line breaks.');</pre><p>Another way to create a multi-line string: use a triple quote with
      either single or double quotation marks.</p><pre class="programlisting">var s1 = '''
You can create
multi-line strings like this one.
''';

var s2 = """This is also a
multi-line string.""";</pre><p>You can create a <span class="quote">“<span class="quote">raw</span>”</span> string by prefixing it with
      <code class="literal">r</code>.</p><pre class="programlisting">var s = r"In a raw string, even \n isn't special.";</pre><p>For more information on using strings, see <a class="xref" href="ch03.html#ch03-strings-and-regular-expressions" title="Strings and regular expressions">Strings and regular expressions</a>.</p></div><div class="sect2" title="Booleans"><h3 id="booleans"/>Booleans</h3><p>To represent boolean values, Dart has a type named <code class="literal">bool</code>. Only two objects have type bool: the
      boolean literals, <code class="literal">true</code> and <code class="literal">false</code>.</p><p>When Dart expects a boolean value, only the value <code class="literal">true</code> is treated as true. All other values are
      treated as false. Unlike in JavaScript, values such as <code class="literal">1</code>, <code class="literal">"aString"</code>, and <code class="literal">someObject</code> are all treated as false.</p><p>For example, consider the following code, which is valid both as
      JavaScript and as Dart code:</p><pre class="programlisting">var name = 'Bob';
if (name) {
  print('You have a name!'); // Prints in JavaScript, not in Dart.
}</pre><p>If you run this code as JavaScript, without compiling to Dart, it
      prints <span class="quote">“<span class="quote">You have a name!</span>”</span> because <code class="literal">name</code> is a non-null object. However, in Dart
      running in <span class="emphasis"><em>production mode</em></span>, the above doesn’t print
      at all because <code class="literal">name</code> is converted to
      <code class="literal">false</code> (because <code class="literal">name != true</code>). In Dart running in
      <span class="emphasis"><em>checked mode</em></span>, the above code throws an exception
      because the <code class="literal">name</code> variable is not a
      bool.</p><p>Here’s another example of code that behaves differently in
      JavaScript and Dart:</p><pre class="programlisting">if (1) {
  print('JavaScript prints this line because it thinks 1 is true.');
} else {
  print('Dart in production mode prints this line.');

  // However, in checked mode, if (1) throws an exception
  // because 1 is not boolean.
}</pre><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>The previous two samples work only in production mode, not
        checked mode. In checked mode, an exception is thrown if a non-boolean
        is used when a boolean value is expected.</p></div><p>Dart’s treatment of booleans is designed to avoid the strange
      behaviors that can arise when many values can be treated as true. What
      this means for you is that, instead of using code like <code class="literal">if (<em class="replaceable"><code>nonbooleanValue</code></em>)</code>,
      you should instead explicitly check for values. For example:</p><pre class="programlisting">// Check for an empty string.
var fullName = '';
assert(fullName.isEmpty());

// Check for zero.
var hitPoints = 0;
assert(hitPoints &lt;= 0);

// Check for null.
var unicorn;
assert(unicorn == null);

// Check for NaN.
var iMeantToDoThis = 0/0;
assert(iMeantToDoThis.isNaN());</pre></div><div class="sect2" title="Lists"><h3 id="lists"/>Lists</h3><p>Perhaps the most common collection in nearly every programming
      language is the <span class="emphasis"><em>array</em></span>, or ordered group of objects.
      In Dart, arrays are <a class="ulink" href="http://api.dartlang.org/dart_core/List.html">List</a> objects,
      so we usually just call them <span class="emphasis"><em>lists</em></span>.</p><p>Dart list literals look like JavaScript array literals. Here’s a
      simple Dart list:</p><pre class="programlisting">var list = [1,2,3];</pre><p>Lists use zero-based indexing, where 0 is the index of the first
      element and <code class="literal">list.length - 1</code> is the
      index of the last element. You can get a list’s length and refer to list
      elements just as you would in JavaScript:</p><pre class="programlisting">var list = [1,2,3];
assert(list.length == 3);
assert(list[1] == 2);</pre><p>The List type and its supertype, <a class="ulink" href="http://api.dartlang.org/dart_core/Collection.html">Collection</a>,
      have many handy methods for manipulating lists. For more information
      about lists, see <a class="xref" href="ch02.html#generics" title="Generics">Generics</a> and <a class="xref" href="ch03.html#ch03-collections" title="Collections">Collections</a>.</p></div><div class="sect2" title="Maps"><h3 id="maps"/>Maps</h3><p>In general, a map is an object that associates keys and values.
      Dart support for maps is provided by map literals and the <a class="ulink" href="http://api.dartlang.org/dart_core/Map.html">Map</a>
      type.</p><p>Here’s a simple Dart map:</p><pre class="programlisting">var gifts = {                         // A map literal
// Keys       Values
  'first'  : 'partridge',
  'second' : 'turtledoves',
  'fifth'  : 'golden rings'
};</pre><p>In map literals, each <span class="emphasis"><em>key</em></span> must be a string.
      If you use a Map constructor, any object can be a key.</p><pre class="programlisting">var map = new Map();                  // use a map constructor.
map[1] = 'partridge';                 // key is 1; value is 'partridge'.
map[2] = 'turtledoves';               // key is 2; value is 'turtledoves'.
map[5] = 'golden rings';              // key is 5; value is 'golden rings'.</pre><p>A map <span class="emphasis"><em>value</em></span> can be any object, including
      null.</p><p>You add a new key-value pair to an existing map just as you would
      in JavaScript:</p><pre class="programlisting">var gifts = { 'first': 'partridge' };
gifts['fourth'] = 'calling birds';    // Add a key-value pair</pre><p>You retrieve a value from a map the same way you would in
      JavaScript:</p><pre class="programlisting">var gifts = { 'first': 'partridge' };
assert(gifts['first'] == 'partridge');</pre><p>If you look for a key that isn’t in a map, you get a null in
      return.</p><pre class="programlisting">var gifts = { 'first': 'partridge' };
assert(gifts['fifth'] == null);</pre><p>Use <code class="literal">.length</code> to get the number
      of key-value pairs in the map:</p><pre class="programlisting">var gifts = { 'first': 'partridge' };
gifts['fourth'] = 'calling birds';
assert(gifts.length == 2);</pre><p>For more information about maps, see <a class="xref" href="ch02.html#generics" title="Generics">Generics</a>
      and <a class="xref" href="ch03.html#ch03-maps-aka-dictionaries-or-hashes" title="Maps">Maps</a>.</p></div></div><div class="sect1" title="Functions"><h2 id="functions"/>Functions</h2><p>Here’s an example of implementing a function:</p><pre class="programlisting">void printNumber(num number) {
  print('The number is $number.');
}</pre><p>Although the style guide recommends specifying the parameter and
    return types, you don’t have to:</p><pre class="programlisting">printNumber(number) {          // Omitting types is OK.
  print('The number is $number.');
}</pre><p>For functions that contain just one expression, you can use a
    shorthand syntax:</p><pre class="programlisting">printNumber(number) =&gt; print('The number is $number.');</pre><p>The <code class="literal">=&gt;
    <em class="replaceable"><code>expr</code></em>;</code> syntax is a shorthand for
    <code class="literal">{ return
    <em class="replaceable"><code>expr</code></em>;}</code>. In the printNumber() function
    above, the expression is the call to the top-level print()
    function.</p><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>Only an <span class="emphasis"><em>expression</em></span>—not a
      <span class="emphasis"><em>statement</em></span>—can appear between the arrow (=&gt;) and
      the semicolon (;). For example, you can’t put an if statement <a class="xref" href="ch02.html#if-else" title="If and else">If and else</a> there, but you can use a conditional (?:)
      expression <a class="xref" href="ch02.html#op-other" title="Other operators">Other operators</a>.</p></div><p>You can use types with =&gt;, although the convention is not to do
    so.</p><pre class="programlisting">printNumber(num number) =&gt; print('The number is $number.'); // Including types is OK.</pre><p>Here’s an example of calling a function:</p><pre class="programlisting">printNumber(123);</pre><p>A function can have two types of parameters: required and optional.
    The required parameters are listed first, followed by any optional
    parameters.</p><div class="sect2" title="Optional parameters"><h3 id="functions-optional-parameters"/>Optional parameters</h3><p>Optional parameters can be either positional or named, but not
      both.</p><p>Both kinds of optional parameter can have default values. The
      default values must be compile-time constants such as literals. If no
      default value is provided, the value is <code class="literal">null</code>.</p><p>If you need to know whether the caller passed in a value for an
      optional parameter, use the syntax <code class="literal">?<em class="replaceable"><code>param</code></em></code>.</p><pre class="programlisting">if (?device) {    // Returns true if the caller specified the parameter.
  //...The user set the value. Do something with it...
}</pre><div class="sect3" title="Optional named parameters"><h4 id="functions-optional-named-parameters"/>Optional named parameters</h4><p>When calling a function, you can specify named parameters using
        <code class="literal"><em class="replaceable"><code>paramName</code></em>:
        <em class="replaceable"><code>value</code></em></code>. For example:</p><pre class="programlisting">enableFlags(bold: true, hidden: false);</pre><p>When defining a function, use <code class="literal">{<em class="replaceable"><code>param1</code></em>,
        <em class="replaceable"><code>param2</code></em>, …}</code> to specify named
        parameters.</p><pre class="programlisting">/// Sets the [bold] and [hidden] flags to the values you specify.
enableFlags({bool bold, bool hidden}) {
  //...
}</pre><p>Use a colon (<code class="literal">:</code>) to specify
        default values.</p><pre class="programlisting">/**
 * Sets the [bold] and [hidden] flags to the values you specify,
 * defaulting to false.
 */
enableFlags({bool bold: false, bool hidden: false}) {
  //...
}

enableFlags(bold: true); // bold will be true; hidden will be false.</pre><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>The preceding two examples use documentation comments <a class="xref" href="ch02.html#comments-doc" title="Documentation comments">Documentation comments</a>.</div></aside><div class="sect3" title="Optional positional parameters"><h4 id="functions-optional-positional-parameters"/>Optional positional parameters</h4><p>Wrapping a set of function parameters in <code class="literal">[]</code> marks them as optional positional
        parameters.</p><pre class="programlisting">String say(String from, String msg, [String device]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  return result;
}</pre><p>Here’s an example of calling this function without the optional
        parameter:</p><pre class="programlisting">assert(say('Bob', 'Howdy') == 'Bob says Howdy');</pre><p>And here’s an example of calling this function with the third
        parameter:</p><pre class="programlisting">assert(say('Bob', 'Howdy', 'smoke signal') ==
  'Bob says Howdy with a smoke signal');</pre><p>Use <code class="literal">=</code> to specify default
        values.</p><pre class="programlisting">String say(String from, String msg,
  [String device='carrier pigeon', String mood]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  if (mood != null) {
    result = '$result (in a $mood mood)';
  }
  return result;
}

assert(say('Bob', 'Howdy') == 'Bob says Howdy with a carrier pigeon');</pre></div></div><div class="sect2" title="Functions as first-class objects"><h3 id="id604561"/>Functions as first-class objects</h3><p>You can pass a function as a parameter to another function. For
      example:</p><pre class="programlisting">printElement(element) {
  print(element);
}
  
var list = [1,2,3];
list.forEach(printElement); // Pass printElement as a parameter.</pre><p>You can also assign a function to a variable, such as:</p><pre class="programlisting">var loudify = (msg) =&gt; '!!! ${msg.toUpperCase()} !!!';
assert(loudify('hello') == '!!! HELLO !!!');</pre></div><div class="sect2" title="Lexical closures"><h3 id="id604585"/>Lexical closures</h3><p>Functions can close over variables defined in surrounding scopes.
      In the following example, makeAdder() captures the variable <code class="literal">n</code> and makes it available to the function that
      makeAdder() returns. Wherever the returned function goes, it remembers
      <code class="literal">n</code>.</p><pre class="programlisting">/// Returns a function that adds [n] to the function's argument.
Function makeAdder(num n) {
  return (num i) =&gt; n + i;
}

main() {
  var add2 = makeAdder(2); // Create a function that adds 2.
  var add4 = makeAdder(4); // Create a function that adds 4.

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}</pre></div><div class="sect2" title="Return values"><h3 id="id286938"/>Return values</h3><p>All functions return a value. If no return value is specified, the
      statement <code class="literal">return null;</code> is implicitly
      appended to the function body.</p></div></div><div class="sect1" title="Operators"><h2 id="operators"/>Operators</h2><p>Dart defines the operators shown in <a class="xref" href="ch02.html#operator_table" title="Table 2-1. Operators and their precedence">Table 2-1</a>. You can override many of these operators, as
    described in <a class="xref" href="ch02.html#classes-operators" title="Operators">Operators</a>.</p><div class="table" id="operator_table"/><p class="title">Table 2-1. Operators and their precedence</p><div class="table-contents"><table summary="Operators and their precedence" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Description</th><th style="border-bottom: 0.5pt solid ; ">Operator</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">unary postfix and argument definition test</td><td style="border-bottom: 0.5pt solid ; "><em class="replaceable"><code>expr</code></em>++
               <em class="replaceable"><code>expr</code></em>--    ()
               []    .   
            ?<em class="replaceable"><code>identifier</code></em></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">unary prefix</td><td style="border-bottom: 0.5pt solid ; ">-<em class="replaceable"><code>expr</code></em>
               !<em class="replaceable"><code>expr</code></em>   
            ~<em class="replaceable"><code>expr</code></em>   
            ++<em class="replaceable"><code>expr</code></em>   
            --<em class="replaceable"><code>expr</code></em>   </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">multiplicative</td><td style="border-bottom: 0.5pt solid ; ">*    /    %
               ~/</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">additive</td><td style="border-bottom: 0.5pt solid ; ">+    -</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">shift</td><td style="border-bottom: 0.5pt solid ; ">&lt;&lt;    &gt;&gt;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">relational and type test</td><td style="border-bottom: 0.5pt solid ; ">&gt;=    &gt;   
            &lt;=    &lt;    as    is
               is!</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">equality</td><td style="border-bottom: 0.5pt solid ; ">==    !=
              </td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">bitwise AND</td><td style="border-bottom: 0.5pt solid ; ">&amp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">bitwise XOR</td><td style="border-bottom: 0.5pt solid ; ">^</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">bitwise OR</td><td style="border-bottom: 0.5pt solid ; ">|</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">logical AND</td><td style="border-bottom: 0.5pt solid ; ">&amp;&amp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">logical OR</td><td style="border-bottom: 0.5pt solid ; ">||</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">conditional</td><td style="border-bottom: 0.5pt solid ; "><em class="replaceable"><code>expr1</code></em> ?
            <em class="replaceable"><code>expr2</code></em> :
            <em class="replaceable"><code>expr3</code></em></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">cascade</td><td style="border-bottom: 0.5pt solid ; ">..</td></tr><tr><td style="border-right: 0.5pt solid ; ">assignment</td><td style="">=    *=    /=
               ~/=    %=    +=    -=
               &lt;&lt;=    &gt;&gt;=    &amp;=
               ^=    |=   </td></tr></tbody></table></div></div><p>When you use operators, you create
    <em class="firstterm">expressions</em>. Here are some examples of operator
    expressions:</p><pre class="programlisting">a++
a + b
a = b
a == b
a? b: c
a is T</pre><p>In <a class="xref" href="ch02.html#operator_table" title="Table 2-1. Operators and their precedence">Table 2-1</a>, each operator has higher
    precedence than the operators in the rows below it. For example, the
    multiplicative operator <code class="literal">%</code> has higher
    precedence than (and thus executes before) the equality operator <code class="literal">==</code>, which has higher precedence than the logical
    AND operator <code class="literal">&amp;&amp;</code>. That
    precedence means that the following two lines of code execute the same
    way:</p><pre class="programlisting">if ((n % i == 0) &amp;&amp; (d % i == 0)) // Parens improve readability.
if (n % i == 0 &amp;&amp; d % i == 0)     // Harder to read, but equivalent.</pre><aside><div class="alert"><strong>Warning: </strong>For operators that work on two operands, the leftmost operand
      determines which version of the operator is used. For example, if you
      have a Vector object and a Point object, <code class="literal">aVector + aPoint</code> uses the Vector version of
      +.</p></div><div class="sect2" title="Arithmetic operators"><h3 id="op-arithmetic"/>Arithmetic operators</h3><p>Dart supports the usual arithmetic operators.</p><div class="table" id="arithmetic_operator_table"/><p class="title">Table 2-2. Arithmetic operators</p><div class="table-contents"><table summary="Arithmetic operators" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Operator</th><th style="border-bottom: 0.5pt solid ; ">Meaning</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">+</td><td style="border-bottom: 0.5pt solid ; ">Add</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">–</td><td style="border-bottom: 0.5pt solid ; ">Subtract</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">-<em class="replaceable"><code>expr</code></em></td><td style="border-bottom: 0.5pt solid ; ">Unary minus, also known as negation (reverse the sign of
              the expression)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">*</td><td style="border-bottom: 0.5pt solid ; ">Multiply</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">/</td><td style="border-bottom: 0.5pt solid ; ">Divide</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">~/</td><td style="border-bottom: 0.5pt solid ; ">Divide, returning an integer result</td></tr><tr><td style="border-right: 0.5pt solid ; ">%</td><td style="">Get the remainder of an integer division (modulo)</td></tr></tbody></table></div></div><p>Example:</p><pre class="programlisting">var a = 2;
var b = 3;

assert(a + b == 5);
assert(a - b == -1);
assert(a * b == 6);
assert( a / b &gt; 0.6 &amp;&amp; a / b &lt; 0.7);
assert(a ~/ b == 0);  // Quotient
assert(a % b == 2);   // Remainder</pre><p>Dart also supports both prefix and postfix increment and decrement
      operators.</p><div class="table" id="pfix_operator_table"/><p class="title">Table 2-3. Increment and decrement operators</p><div class="table-contents"><table summary="Increment and decrement operators" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Operator</th><th style="border-bottom: 0.5pt solid ; ">Meaning</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">++<em class="replaceable"><code>var</code></em></td><td style="border-bottom: 0.5pt solid ; "><em class="replaceable"><code>var</code></em> =
              <em class="replaceable"><code>var</code></em> + 1 (expression value is
              <em class="replaceable"><code>var</code></em> + 1)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><em class="replaceable"><code>var</code></em>++</td><td style="border-bottom: 0.5pt solid ; "><em class="replaceable"><code>var</code></em> =
              <em class="replaceable"><code>var</code></em> + 1 (expression value is
              <em class="replaceable"><code>var</code></em>)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">--<em class="replaceable"><code>var</code></em></td><td style="border-bottom: 0.5pt solid ; "><em class="replaceable"><code>var</code></em> =
              <em class="replaceable"><code>var</code></em> – 1 (expression value is
              <em class="replaceable"><code>var</code></em> – 1)</td></tr><tr><td style="border-right: 0.5pt solid ; "><em class="replaceable"><code>var</code></em>--</td><td style=""><em class="replaceable"><code>var</code></em> =
              <em class="replaceable"><code>var</code></em> – 1 (expression value is
              <em class="replaceable"><code>var</code></em>)</td></tr></tbody></table></div></div><p>Example:</p><pre class="programlisting">var a, b;

a = 0;  
b = ++a;         // Increment a before b gets its value.
assert(a == b);  // 1 == 1  

a = 0;
b = a++;         // Increment a AFTER b gets its value.
assert(a != b);  // 1 != 0

a = 0;
b = --a;         // Decrement a before b gets its value.
assert(a == b);  // -1 == -1

a = 0;
b = a--;         // Decrement a AFTER b gets its value.
assert(a != b) ; // -1 != 0</pre></div><div class="sect2" title="Equality and relational operators"><h3 id="op-equality"/>Equality and relational operators</h3><div class="table" id="equality_operator_table"/><p class="title">Table 2-4. Equality and relational operators</p><div class="table-contents"><table summary="Equality and relational operators" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Operator</th><th style="border-bottom: 0.5pt solid ; ">Meaning</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">==</td><td style="border-bottom: 0.5pt solid ; ">Equal; see discussion below</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">!=</td><td style="border-bottom: 0.5pt solid ; ">Not equal</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&gt;</td><td style="border-bottom: 0.5pt solid ; ">Greater than</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&lt;</td><td style="border-bottom: 0.5pt solid ; ">Less than</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&gt;=</td><td style="border-bottom: 0.5pt solid ; ">Greater than or equal to</td></tr><tr><td style="border-right: 0.5pt solid ; ">&lt;=</td><td style="">Less than or equal to</td></tr></tbody></table></div></div><p>To test whether two objects <em class="replaceable"><code>x</code></em> and
      <em class="replaceable"><code>y</code></em> represent the same thing, use the <code class="literal">==</code> operator. Here’s how the <code class="literal">==</code> operator works:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>If <em class="replaceable"><code>x</code></em> or
          <em class="replaceable"><code>y</code></em> is null, return true if both are null,
          and false if only one is null.</p></li><li class="listitem"><p>Return the result of the method invocation <code class="literal"><em class="replaceable"><code>x</code></em>.==(<em class="replaceable"><code>y</code></em>)</code>.
          That’s right, operators such as <code class="literal">==</code> are methods that are invoked on their
          first operand. You’ll see more about this in <a class="xref" href="ch02.html#classes-operators" title="Operators">Operators</a>.</p></li></ol></div><p>Here’s an example of using each of the equality and relational
      operators:</p><pre class="programlisting">var a = 2;
var b = 3;
var c = a;

assert(a == 2);       // 2 and 2 are equal.
assert(a != b);       // 2 and 3 aren't equal.
assert(b &gt; a);        // 3 is more than 2.
assert(a &lt; b);        // 2 is less then 3.
assert(b &gt;= b);       // 3 is greater than or equal to 3.
assert(a &lt;= b);       // 2 is less than or equal to 3.</pre></div><div class="sect2" title="Type test operators"><h3 id="id562432"/>Type test operators</h3><p>The <code class="literal">as</code>, <code class="literal">is</code>, and <code class="literal">is!</code>
      operators are handy for checking types at runtime.</p><div class="table" id="type_test_operator_table"/><p class="title">Table 2-5. Type test operators</p><div class="table-contents"><table summary="Type test operators" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Operator</th><th style="border-bottom: 0.5pt solid ; ">Meaning</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">as</td><td style="border-bottom: 0.5pt solid ; ">Typecast</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">is</td><td style="border-bottom: 0.5pt solid ; ">True if the object has the specified type</td></tr><tr><td style="border-right: 0.5pt solid ; ">is!</td><td style="">False if the object has the specified type</td></tr></tbody></table></div></div><p>The result of <code class="literal">obj is T</code> is true
      if <code class="literal">obj</code> implements the interface
      specified by <code class="literal">T</code>. For example, <code class="literal">obj is Object</code> is always true.</p><p>Use the <code class="literal">as</code> operator to cast an
      object to a particular type. In general, you should use it as a
      shorthand for an <code class="literal">is</code> test on an object
      following by an expression using that object. For example, consider the
      following code:</p><pre class="programlisting">if (person is Person) {               // Type check
  person.firstName = 'Bob';
}</pre><p>You can make the code shorter using the <code class="literal">as</code> operator:</p><pre class="programlisting">(person as Person).firstName = 'Bob';</pre></div><div class="sect2" title="Assignment operators"><h3 id="op-assign"/>Assignment operators</h3><p>As you’ve already seen, you assign values using the <code class="literal">=</code> operator. You can also use compound
      assignment operators such as <code class="literal">+=</code>,
      which combine an operation with an assignment.</p><div class="table" id="assignment_operator_table"/><p class="title">Table 2-6. Assignment operators</p><div class="table-contents"><table summary="Assignment operators" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">=</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">*=</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">%=</td><td style="border-bottom: 0.5pt solid ; ">&amp;=</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">+=</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">/=</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&lt;&lt;=</td><td style="border-bottom: 0.5pt solid ; ">^=</td></tr><tr><td style="border-right: 0.5pt solid ; ">–=</td><td style="border-right: 0.5pt solid ; ">~/=</td><td style="border-right: 0.5pt solid ; ">&gt;&gt;=</td><td style="">|=</td></tr></tbody></table></div></div><p>Here’s how compound assignment operators work:</p><div class="informaltable" id="assignment_operator_concepts_table"/><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Compound assignment</th><th style="border-bottom: 0.5pt solid ; ">Equivalent expression</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><span class="bold"><strong>For an operator
              <em class="replaceable"><code>op</code></em>:</strong></span></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><code class="literal">a <em class="replaceable"><code>op</code></em>=
              b</code></td><td style="border-bottom: 0.5pt solid ; "><code class="literal">a = a
              <em class="replaceable"><code>op</code></em> b</code></td></tr><tr><td style="border-right: 0.5pt solid ; "><span class="bold"><strong>Example: </strong></span></td><td style="border-right: 0.5pt solid ; "><code class="literal">a += b</code></td><td style=""><code class="literal">a = a + b</code></td></tr></tbody></table></div><p>The following example uses both assignment and compound assignment
      operators:</p><pre class="programlisting">var a = 2;           // Assign using =
a *= 3;              // Assign and multiply: a = a * 3
assert(a == 6);</pre></div><div class="sect2" title="Logical operators"><h3 id="op-logical"/>Logical operators</h3><p>You can invert or combine boolean expressions using the logical
      operators.</p><div class="table" id="logical_operator_table"/><p class="title">Table 2-7. Logical operators</p><div class="table-contents"><table summary="Logical operators" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Operator</th><th style="border-bottom: 0.5pt solid ; ">Meaning</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">!<em class="replaceable"><code>expr</code></em></td><td style="border-bottom: 0.5pt solid ; ">inverts the following expression (changes false to true,
              and vice versa)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">||</td><td style="border-bottom: 0.5pt solid ; ">logical OR</td></tr><tr><td style="border-right: 0.5pt solid ; ">&amp;&amp;</td><td style="">logical AND</td></tr></tbody></table></div></div><p>Here’s an example of using the logical operators.</p><pre class="programlisting">if (!done &amp;&amp; (col == 0 || col == 3)) {
  // ...Do something...
}</pre></div><div class="sect2" title="Bitwise and shift operators"><h3 id="op-bit"/>Bitwise and shift operators</h3><p>You can manipulate the individual bits of numbers in Dart.
      Usually, you’d use these bitwise and shift operators with
      integers.</p><div class="table" id="bit_operator_table"/><p class="title">Table 2-8. Bitwise and shift operators</p><div class="table-contents"><table summary="Bitwise and shift operators" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Operator</th><th style="border-bottom: 0.5pt solid ; ">Meaning</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&amp;</td><td style="border-bottom: 0.5pt solid ; ">AND</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">|</td><td style="border-bottom: 0.5pt solid ; ">OR</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">^</td><td style="border-bottom: 0.5pt solid ; ">XOR</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">~<em class="replaceable"><code>expr</code></em></td><td style="border-bottom: 0.5pt solid ; ">Unary bitwise complement (0s become 1s; 1s become
              0s)</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&lt;&lt;</td><td style="border-bottom: 0.5pt solid ; ">Shift left</td></tr><tr><td style="border-right: 0.5pt solid ; ">&gt;&gt;</td><td style="">Shift right</td></tr></tbody></table></div></div><p>Here’s an example of using bitwise and shift operators.</p><pre class="programlisting">final value = 0x22;
final bitmask = 0x0f;

assert((value &amp; bitmask)  == 0x02);  // AND
assert((value &amp; ~bitmask) == 0x20);  // AND NOT
assert((value | bitmask)  == 0x2f);  // OR
assert((value ^ bitmask)  == 0x2d);  // XOR
assert((value &lt;&lt; 4)       == 0x220); // Shift left
assert((value &gt;&gt; 4)       == 0x02);  // Shift right</pre></div><div class="sect2" title="Other operators"><h3 id="op-other"/>Other operators</h3><p>A few operators remain, most of which you’ve already seen in other
      examples.</p><div class="table" id="other_operator_table"/><p class="title">Table 2-9. Other operators</p><div class="table-contents"><table summary="Other operators" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Operator</th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Name</th><th style="border-bottom: 0.5pt solid ; ">Meaning</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">()</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Function application</td><td style="border-bottom: 0.5pt solid ; ">Represents a function call</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">[]</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">List access</td><td style="border-bottom: 0.5pt solid ; ">Refers to the value at the specified index in the
              list</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><em class="replaceable"><code>expr1</code></em> ? <em class="replaceable"><code>expr2</code></em> : <em class="replaceable"><code>expr3</code></em></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Conditional</td><td style="border-bottom: 0.5pt solid ; ">If <em class="replaceable"><code>expr1</code></em> is true, executes
              <em class="replaceable"><code>expr2</code></em>; otherwise, executes
              <em class="replaceable"><code>expr3</code></em></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">.</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Member access</td><td style="border-bottom: 0.5pt solid ; ">Refers to a property of an expression; example: <code class="literal">foo.bar</code> selects property <code class="literal">bar</code> from expression <code class="literal">foo</code></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">..</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Cascade</td><td style="border-bottom: 0.5pt solid ; ">Allows you to perform multiple
              operations on the members of a single object; described in <a class="xref" href="ch02.html#classes" title="Classes">Classes</a></td></tr><tr><td style="border-right: 0.5pt solid ; ">?<em class="replaceable"><code>identifier</code></em></td><td style="border-right: 0.5pt solid ; ">Argument definition test</td><td style="">Tests whether the caller specified an optional parameter;
              described in <a class="xref" href="ch02.html#functions-optional-parameters" title="Optional parameters">Optional parameters</a></td></tr></tbody></table></div></div></div></div><div class="sect1" title="Control flow statements"><h2 id="control-flow-statements"/>Control flow statements</h2><p>You can control the flow of your Dart code using any of the
    following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">if</code> and <code class="literal">else</code></p></li><li class="listitem"><p><code class="literal">for</code> loops</p></li><li class="listitem"><p><code class="literal">while</code> and <code class="literal">do</code>-<code class="literal">while</code>
        loops</p></li><li class="listitem"><p><code class="literal">break</code> and <code class="literal">continue</code></p></li><li class="listitem"><p><code class="literal">switch</code> and <code class="literal">case</code></p></li><li class="listitem"><p><code class="literal">assert</code></p></li></ul></div><p>You can also affect the control flow using <code class="literal">try-catch</code> and <code class="literal">throw</code>, as explained in <a class="xref" href="ch02.html#exceptions" title="Exceptions">Exceptions</a>.</p><div class="sect2" title="If and else"><h3 id="if-else"/>If and else</h3><p>Dart supports <code class="literal">if</code> statements
      with optional <code class="literal">else</code> statements. Also
      see conditional expressions (?:), covered in <a class="xref" href="ch02.html#op-other" title="Other operators">Other operators</a>.</p><pre class="programlisting">if (isRaining()) {
  you.bringRainCoat();
} else if (isSnowing()) {
  you.wearJacket();
} else {
  car.putTopDown();
}</pre><p>Remember, unlike JavaScript, Dart treats all values other than
      <code class="literal">true</code> as <code class="literal">false</code>. See <a class="xref" href="ch02.html#booleans" title="Booleans">Booleans</a> for
      more information.</p></div><div class="sect2" title="For loops"><h3 id="for-loops"/>For loops</h3><p>You can iterate with the standard <code class="literal">for</code> loop.</p><pre class="programlisting">for (int i = 0; i &lt; candidates.length; i++) {
  candidates[i].interview();
}</pre><p>Closures inside of Dart’s <code class="literal">for</code>
      loops capture the value of the index, avoiding a common pitfall found in
      JavaScript. For example, consider:</p><pre class="programlisting">var callbacks = [];
for (var i = 0; i &lt; 2; i++) {
  callbacks.add(() =&gt; print(i));
}
callbacks.forEach((c) =&gt; c());</pre><p>The output is <code class="literal">0</code> and then
      <code class="literal">1</code>, as expected. In contrast, the
      example would print <code class="literal">2</code> and then
      <code class="literal">2</code> in JavaScript.</p><p>If the object that you are iterating over is a Collection, you can
      use the <a class="ulink" href="http://api.dartlang.org/dart_core/Collection.html#forEach">forEach()</a>
      method. Using forEach() is a good option if you don’t need to know the
      current iteration counter.</p><pre class="programlisting">candidates.forEach((candidate) =&gt; candidate.interview());</pre><p>Collections also support the <code class="literal">for-in</code> form of iteration, as described in
      <a class="xref" href="ch03.html#ch03-iteration" title="Iteration">Iteration</a>.</p><pre class="programlisting">var collection = [0, 1, 2];
for (var x in collection) {
  print(x);
}</pre></div><div class="sect2" title="While and do-while"><h3 id="while"/>While and do-while</h3><p>A <code class="literal">while</code> loop evaluates the
      condition before the loop.</p><pre class="programlisting">while(!isDone()) {
  doSomething();
}</pre><p>A <code class="literal">do</code>-<code class="literal">while</code> loop evaluates the condition
      <span class="emphasis"><em>after</em></span> the loop.</p><pre class="programlisting">do {
  printLine();
} while (!atEndOfPage());</pre></div><div class="sect2" title="Break and continue"><h3 id="break"/>Break and continue</h3><p>Use <code class="literal">break</code> to stop
      looping.</p><pre class="programlisting">while (true) {
  if (shutDownRequested()) break;
  processIncomingRequests();
}</pre><p>Use <code class="literal">continue</code> to skip to the
      next loop iteration.</p><pre class="programlisting">for (int i = 0; i &lt; candidates.length; i++) {
  var candidate = candidates[i];
  if (candidate.yearsExperience &lt; 5) {
    continue;
  }
  candidate.interview();
}</pre><p>You might write that example differently if you’re using a <a class="ulink" href="http://api.dartlang.org/dart_core/Collection.html">Collection.</a></p><pre class="programlisting">candidates.filter((c) =&gt; c.yearsExperience &gt;= 5)
          .forEach((c) =&gt; c.interview());</pre></div><div class="sect2" title="Switch and case"><h3 id="switch"/>Switch and case</h3><p>Switch statements in Dart compare integer, string, or compile-time
      constants using <code class="literal">==</code>. The compared
      objects must all be instances of the same class (and not of any of its
      subtypes), and the class must not override <code class="literal">==</code>.</p><p>Each non-empty <code class="literal">case</code> clause ends
      with a <code class="literal">break</code> statement, as a rule.
      Other valid ways to end a non-empty <code class="literal">case</code> clause are a <code class="literal">continue</code>, <code class="literal">throw</code>, or <code class="literal">return</code> statement.</p><p>Use a <code class="literal">default</code> clause to execute
      code when no <code class="literal">case</code> clause
      matches.</p><pre class="programlisting">var command = 'OPEN';
switch (command) {
  case 'CLOSED':
    executeClosed();
    break;
  case 'PENDING':
    executePending();
    break;
  case 'APPROVED':
    executeApproved();
    break;
  case 'DENIED':
    executeDenied();
    break;
  case 'OPEN':
    executeOpen();
    break;
  default:
    executeUnknown();
}</pre><p>The following example omits the <code class="literal">break</code> statement in the <code class="literal">case</code> clause, thus generating an error:</p><pre class="programlisting">var command = 'OPEN';
switch (command) {
  case 'OPEN':
    executeOpen();
    // ERROR: Missing break causes an exception to be thrown!!

  case 'CLOSED':
    executeClosed();
    break;
}</pre><p>However, Dart does support empty <code class="literal">case</code> clauses, allowing a form of
      fall-through.</p><pre class="programlisting">var command = 'CLOSED';
switch (command) {
  case 'CLOSED':     // Empty case falls through.
  case 'NOW_CLOSED':
    // Runs for both CLOSED and NOW_CLOSED.
    executeNowClosed();
    break;
}</pre><p>If you really want fall-through, you can use a <code class="literal">continue</code> statement and a label.</p><pre class="programlisting">var command = 'CLOSED';
switch (command) {
  case 'CLOSED':
    executeClosed();
    continue nowClosed; // Continues executing at the nowClosed label.

nowClosed:
  case 'NOW_CLOSED':
    // Runs for both CLOSED and NOW_CLOSED.
    executeNowClosed();
    break;
}</pre><p>A <code class="literal">case</code> clause can have local
      variables, which are visible only inside the scope of that
      clause.</p></div><div class="sect2" title="Assert"><h3 id="assert"/>Assert</h3><p>Use an <code class="literal">assert</code> statement to
      disrupt normal execution if a boolean condition is false. You can find
      examples of assert statements throughout this tour. Here are some
      more:</p><pre class="programlisting">assert(text != null);  // Make sure the variable has a non-null value.
assert(number &lt; 100);  // Make sure the value is less than 100.
assert(urlString.startsWith('https')); // Make sure this is an HTTPS URL.</pre><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>Assert statements work only in checked mode. They have no effect
        in production mode.</p></div><p>Inside the parentheses after <code class="literal">assert</code>, you can put any expression that
      resolves to a boolean value or to a function. If the expression’s value
      or function’s return value is true, the assertion succeeds and execution
      continues. Otherwise, the assertion fails and an exception (an <a class="ulink" href="http://api.dartlang.org/dart_core/AssertionError.html">AssertionError</a>)
      is thrown.</p></div></div><div class="sect1" title="Exceptions"><h2 id="exceptions"/>Exceptions</h2><p>Your Dart code can throw and catch exceptions. Exceptions are errors
    indicating that something unexpected happened. If the exception isn’t
    caught, the isolate that raised the exception is suspended, and typically
    the isolate and its program are terminated.</p><p>In contrast to Java, all of Dart’s exceptions are unchecked
    exceptions. Methods do not declare which exceptions they might throw, and
    you are not required to catch any exceptions.</p><p>Dart provides <a class="ulink" href="http://api.dartlang.org/dart_core/Exception.html">Exception</a>
    and <a class="ulink" href="http://api.dartlang.org/docs/continuous/dart_core/Error.html">Error</a>
    types, as well as numerous predefined subtypes. You can, of course, define
    your own exceptions. However, Dart programs can throw any non-null
    object—not just Exception and Error objects—as an exception.</p><div class="sect2" title="Throw"><h3 id="id575483"/>Throw</h3><p>Here’s an example of throwing, or <span class="emphasis"><em>raising</em></span>, an
      exception.</p><pre class="programlisting">throw new ExpectException('Value must be greater than zero');</pre><p>You can also throw arbitrary objects.</p><pre class="programlisting">throw 'Out of llamas!';</pre><p>Because throwing an exception is an expression, you can throw
      exceptions in =&gt; statements, as well as anywhere else that allows
      expressions:</p><pre class="programlisting">String get prettyVersion() =&gt; throw const NotImplementedException();</pre></div><div class="sect2" title="Catch"><h3 id="id593095"/>Catch</h3><p>Catching, or capturing, an exception stops the exception from
      propagating. Catching an exception gives you a chance to handle
      it.</p><pre class="programlisting">try {
  breedMoreLlamas();
} on OutOfLlamasException {
  buyMoreLlamas();
}</pre><p>To handle code that can throw more than one type of exception, you
      can specify multiple catch clauses. The first catch clause that matches
      the thrown object’s type handles the exception. If the catch clause does
      not specify a type, that clause can handle any type of thrown
      object.</p><pre class="programlisting">try {
  breedMoreLlamas();
} on OutOfLlamasException {           // A specific exception
  buyMoreLlamas();
} on Exception catch(e) {             // Anything else that is an exception
  print('Unknown exception: $e');
} catch(e) {                          // No specified type, handles all
  print('Something really unknown: $e');
}</pre><p>As the preceding code shows, you can use either <code class="literal">on</code> or <code class="literal">catch</code>
      or both. Use <code class="literal">on</code> when you need to
      specify the exception type. Use <code class="literal">catch</code>
      when your exception handler needs the exception object.</p></div><div class="sect2" title="Finally"><h3 id="id626774"/>Finally</h3><p>To ensure that some code runs whether or not an exception is
      thrown, use a <code class="literal">finally</code> clause. If no
      catch clause matches the exception, the exception is propagated after
      the finally clause runs.</p><pre class="programlisting">try {
  breedMoreLlamas();
} finally {
  cleanLlamaStalls();  // Always clean up, even if an exception is thrown.
}</pre><p>The finally clause runs after any matching catch clauses.</p><pre class="programlisting">try {
  breedMoreLlamas();
} catch(e) {
  print('Error: $e');  // Handle the exception first.
} finally {
  cleanLlamaStalls();  // Then clean up.
}</pre><p>Learn more by reading <a class="xref" href="ch03.html#ch03-exceptions" title="Exceptions">Exceptions</a>.</p></div></div><div class="sect1" title="Classes"><h2 id="classes"/>Classes</h2><p>Dart is an object-oriented language with classes and single
    inheritance. Every object is an instance of a class, and all classes
    descend from <a class="ulink" href="http://api.dartlang.org/dart_core/Object.html">Object</a>.</p><p>To create an object, you can use the <code class="literal">new</code> keyword with a
    <em class="firstterm">constructor</em> for a class. Constructor names can be
    either <span class="emphasis"><em><em class="replaceable"><code>ClassName</code></em></em></span> or
    <em class="replaceable"><code>ClassName.identifier</code></em>.</p><pre class="programlisting">var jsonData = JSON.parse('{"x":1, "y":2}');

var p1 = new Point(2,2);               // Create a Point with the Point() constructor.
var p2 = new Point.fromJson(jsonData); // Create a Point with the Point.fromJson() constructor.</pre><p>Objects have <em class="firstterm">members</em> consisting of functions
    and data (<em class="firstterm">methods</em> and <em class="firstterm">instance
    variables</em>, respectively). When you call a method, you
    <span class="emphasis"><em>invoke</em></span> it on an object: the method has access to that
    object’s functions and data.</p><p>Use a dot (.) to refer to an instance variable or method.</p><pre class="programlisting">var p = new Point(2,2);

p.y = 3;             // Set the value of the instance variable y.
assert(p.y == 3);    // Get the value of y.

num distance = p.distanceTo(new Point(4,4)); // Invoke the distanceTo() method on p.</pre><p>Use the cascade operator (..) when you want to perform a series of
    operations on the members of a single object.</p><pre class="programlisting">query('#button')
    ..text = 'Click to Confirm'                        // Get an object, and use its
    ..classes.add('important')                         // instance variables/methods
    ..on.click.add((e) =&gt; window.alert('Confirmed!')); // without repeating yourself.</pre><p>Some classes provide constant constructors. To create a compile-time
    constant using a constant constructor, use <code class="literal">const</code> instead of <code class="literal">new</code>.</p><pre class="programlisting">var p = const ImmutablePoint(2,2);</pre><p>Constructing two identical compile-time constants results in a
    single, canonical instance.</p><pre class="programlisting">var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);

assert(identical(a,b)); // They are the same instance!</pre><p>The following sections discuss how to implement classes.</p><div class="sect2" title="Instance variables"><h3 id="id368594"/>Instance variables</h3><p>Here’s how you declare instance variables:</p><pre class="programlisting">class Point {
  num x;      // Declare an instance variable (x), initially null.
  num y;      // Declare y, initially null.
  num z = 0;  // Declare z, initially 0.
}</pre><p>All uninitialized instance variables have the value <code class="literal">null</code>.</p><p>All instance variables generate an implicit
      <em class="firstterm">getter</em> method. Non-final, non-const instance
      variables also generate an implicit <em class="firstterm">setter</em>
      method. For details, see <a class="xref" href="ch02.html#classes-getters-and-setters" title="Getters and setters">Getters and setters</a>.</p><pre class="programlisting">class Point {
  num x;
  num y;
}

main() {
  var point = new Point();
  point.x = 4;             // Use the setter method for x.
  assert(point.x == 4);    // Use the getter method for x.
  assert(point.y == null); // Values default to null.
}</pre><p>If you initialize an instance variable where it is declared
      (instead of in a constructor or method), the value is set when the
      instance is created, which is before the constructor and its initializer
      list execute.</p></div><div class="sect2" title="Constructors"><h3 id="id427950"/>Constructors</h3><p>Declare a constructor by creating a function with the same name as
      its class (plus, optionally, an additional identifier as described in
      <a class="xref" href="ch02.html#ch02-constructors-named" title="Named constructors">Named constructors</a>). The most common form of
      constructor, the generative constructor, creates a new instance of a
      class.</p><pre class="programlisting">class Point {
  num x;
  num y;

  Point(num x, num y) {
    // There's a better way to do this, stay tuned.
    this.x = x;
    this.y = y;
  }
}</pre><p>The <code class="literal">this</code> keyword refers to the
      current instance.</p><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>Use <code class="literal">this</code> only when there is a
        name conflict. Otherwise, Dart style omits the <code class="literal">this</code>.</p></div><p>The pattern of assigning a constructor argument to an instance
      variable is so common, Dart has syntactic sugar to make it easy.</p><pre class="programlisting">class Point {
  num x;
  num y;

  // Syntactic sugar for setting x and y before the constructor body runs.
  Point(this.x, this.y);
}</pre><div class="sect3" title="Default constructors"><h4 id="id472051"/>Default constructors</h4><p>If you don’t declare a constructor, a default constructor is
        provided for you. The default constructor has no arguments and invokes
        the no-argument constructor in the superclass.</p></div><div class="sect3" title="Constructors aren’t inherited"><h4 id="id626893"/>Constructors aren’t inherited</h4><p>Subclasses don’t inherit constructors from their superclass. A
        subclass that declares no constructors has only the default (no
        argument, no name) constructor.</p></div><div class="sect3" title="Named constructors"><h4 id="ch02-constructors-named"/>Named constructors</h4><p>Use a named constructor to implement multiple constructors for a
        class or to provide extra clarity.</p><pre class="programlisting">class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // Named constructor
  Point.fromJson(Map json) {
    x = json['x'];
    y = json['y'];
  }
}</pre><p>Remember that constructors are not inherited, which means that a
        superclass’s named constructor is not inherited by a subclass. If you
        want a subclass to be created with a named constructor defined in the
        superclass, you must implement that constructor in the
        subclass.</p></div><div class="sect3" title="Invoking a non-default superclass constructor"><h4 id="id293475"/>Invoking a non-default superclass constructor</h4><p>By default, a constructor in a subclass calls the superclass’s
        unnamed, no-argument constructor. If the superclass doesn’t have such
        a constructor, then you must manually call one of the constructors in
        the superclass. Specify the superclass constructor after a colon (:),
        just before the constructor body (if any).</p><pre class="programlisting">class Person {
  Person.fromJson(Map data) {
    print('in Person');
  }
}

class Employee extends Person {
  // Person does not have a default constructor;
  // you must call super.fromJson(data).
  Employee.fromJson(Map data) : super.fromJson(data) {
    print('in Employee');
  }
}

main() {
  var emp = new Employee.fromJson({});

  // Prints:
  // in Person
  // in Employee
}</pre></div><div class="sect3" title="Initializer list"><h4 id="id626944"/>Initializer list</h4><p>Besides invoking a superclass constructor, you can also
        initialize instance variables before the constructor body runs.
        Separate initializers with commas.</p><pre class="programlisting">class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // Use an initializer list to set instance variables before the constructor body runs.
  Point.fromJson(Map json) : x = json['x'], y = json['y'] {
    print('In Point.fromJson(): ($x, $y)');
  }
}</pre><aside><div class="alert"><strong>Warning: </strong>The right-hand side of an initializer does not have access to
          <code class="literal">this</code>.</div></aside><div class="sect3" title="Redirecting constructors"><h4 id="id626970"/>Redirecting constructors</h4><p>Sometimes a constructor’s only purpose is to redirect to another
        constructor in the same class. A redirecting constructor’s body is
        empty, with the constructor call appearing after a colon (:).</p><pre class="programlisting">class Point {
  num x;
  num y;

  Point(this.x, this.y);                // The main constructor for this class.
  Point.alongXAxis(num x) : this(x, 0); // Delegates to the main constructor.
}</pre></div><div class="sect3" title="Constant constructors"><h4 id="id626988"/>Constant constructors</h4><p>If your class produces objects that never change, you can make
        these objects compile-time constants. To do this, define a <code class="literal">const</code> constructor and make sure that all
        instance variables are <code class="literal">final</code> or
        <code class="literal">const</code>.</p><pre class="programlisting">class ImmutablePoint {
  final num x;
  final num y;
  const ImmutablePoint(this.x, this.y);
  static final ImmutablePoint origin = const ImmutablePoint(0, 0);
}</pre></div><div class="sect3" title="Factory constructors"><h4 id="ch02-constructor-factory"/>Factory constructors</h4><p>Use the <code class="literal">factory</code> keyword when
        implementing a constructor that doesn’t always create a new instance
        of its class. For example, a factory constructor might return an
        instance from a cache, or it might return an instance of a
        subtype.</p><p>The following example demonstrates a factory constructor
        returning objects from a cache.</p><pre class="programlisting">class Logger {
  final String name;
  bool mute = false;

  // _cache is library-private, thanks to the _ in front of its name.
  static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;{};
  
  factory Logger(String name) {
    if (_cache.containsKey(name)) {
      return _cache[name];
    } else {
      final logger = new Logger._internal(name);
      _cache[name] = logger;
      return logger;
    }
  }
  
  Logger._internal(this.name);
  
  void log(String msg) {
    if (!mute) {
      print(msg);
    }
  }
}</pre><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>Factory constructors have no access to <code class="literal">this</code>.</p></div><p>To invoke a factory constructor, you use the <code class="literal">new</code> keyword:</p><pre class="programlisting">var logger = new Logger('UI');
logger.log('Button clicked');</pre></div></div><div class="sect2" title="Methods"><h3 id="id527206"/>Methods</h3><p>Methods are functions that provide behavior for an object.</p><div class="sect3" title="Instance methods"><h4 id="id531122"/>Instance methods</h4><p>Instance methods on objects can access instance variables and
        <code class="literal">this</code>. The distanceTo() method in
        the following sample is an example of an instance method.</p><pre class="programlisting">class Point {
  num x;
  num y;
  Point(this.x, this.y);

  num distanceTo(Point other) {
    var dx = x - other.x;
    var dy = y - other.y;
    return sqrt(dx * dx + dy * dy);
  }
}</pre></div><div class="sect3" title="Getters and setters"><h4 id="classes-getters-and-setters"/>Getters and setters</h4><p>Getters and setters are special methods that provide read and
        write access to an object’s properties. Recall that each instance
        variable has an implicit getter, plus a setter if appropriate. You can
        create additional properties by implementing getters and setters,
        using the <code class="literal">get</code> and <code class="literal">set</code> keywords.</p><pre class="programlisting">class Rectangle {
  num left;
  num top;
  num width;
  num height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Define two calculated properties: right and bottom.
  num get right             =&gt; left + width;
      set right(num value)  =&gt; left = value - width;
  num get bottom            =&gt; top + height;
      set bottom(num value) =&gt; top = value - height;
}

main() {
  var rect = new Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}</pre><p>With getters and setters, you can start with instance variables,
        later wrapping them with methods, all without changing client
        code.</p><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>Operators such as increment (++) work in the expected way,
            whether or not a getter is explicitly defined. To avoid any
            unexpected side effects, the operator calls the getter exactly
            once, saving its value in a temporary variable.</div></aside><div class="sect3" title="Abstract methods"><h4 id="ch02-method-abstract"/>Abstract methods</h4><p>Instance, getter, and setter methods can be abstract, defining
        an interface but leaving its implementation up to other classes. To
        make a method abstract, use a semicolon (;) instead of a method
        body.</p><pre class="programlisting">abstract class Doer {
  // ...Define instance variables and methods...
 
  void doSomething(); // Define an abstract method.
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // ...Provide an implementation, so the method is not abstract in this class...
  }
}</pre><p>Calling an abstract method results in a run-time error.</p><p>Also see <a class="xref" href="ch02.html#ch02-class-abstract" title="Abstract classes">Abstract classes</a>.</p></div><div class="sect3" title="Operators"><h4 id="classes-operators"/>Operators</h4><p>You can override the operators shown in <a class="xref" href="ch02.html#overridden_operator_table" title="Table 2-10. Operators that can be overridden">Table 2-10</a>. For example, if you define a
        Vector class, you might define a + method to add two vectors.</p><div class="table" id="overridden_operator_table"/><p class="title">Table 2-10. Operators that can be overridden</p><div class="table-contents"><table summary="Operators that can be overridden" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&lt;</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">+</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">|</td><td style="border-bottom: 0.5pt solid ; ">[]</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&gt;</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">/</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">^</td><td style="border-bottom: 0.5pt solid ; ">[]=</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&lt;=</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">~/</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&amp;</td><td style="border-bottom: 0.5pt solid ; ">~</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&gt;=</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">*</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">&lt;&lt;</td><td style="border-bottom: 0.5pt solid ; ">==</td></tr><tr><td style="border-right: 0.5pt solid ; ">–</td><td style="border-right: 0.5pt solid ; ">%</td><td style="border-right: 0.5pt solid ; ">&gt;&gt;</td><td class="auto-generated" style=""> </td></tr></tbody></table></div></div><p>Here’s an example of a class that overrides the <code class="literal">+</code> and <code class="literal">-</code>
        operators.</p><pre class="programlisting">class Vector {
  final int x;
  final int y;
  const Vector(this.x, this.y);

  Vector operator +(Vector v) { // Overrides + (a + b).
    return new Vector(x + v.x, y + v.y);
  }

  Vector operator -(Vector v) { // Overrides - (a - b).
    return new Vector(x - v.x, y - v.y);
  }
}

main() {
  final v = new Vector(2,3);
  final w = new Vector(2,2);

  assert(v.x == 2 &amp;&amp; v.y == 3);         // v   == (2,3)
  assert((v+w).x == 4 &amp;&amp; (v+w).y == 5); // v+w == (4,5)
  assert((v-w).x == 0 &amp;&amp; (v-w).y == 1); // v-w == (0,1)
}</pre><p>For an example of overriding <code class="literal">==</code>, see <a class="xref" href="ch03.html#ch03-implementing-map-keys" title="Implementing map keys">Implementing map keys</a>.</p></div></div><div class="sect2" title="Abstract classes"><h3 id="ch02-class-abstract"/>Abstract classes</h3><p>Use the <code class="literal">abstract</code> modifier to
      define an <em class="firstterm">abstract class</em>—a class that can’t be
      instantiated. Abstract classes are useful for defining interfaces, often
      with some implementation. If you want your abstract class to appear to
      be instantiable, define a factory constructor <a class="xref" href="ch02.html#ch02-constructor-factory" title="Factory constructors">Factory constructors</a>.</p><p>Abstract classes often have abstract methods <a class="xref" href="ch02.html#ch02-method-abstract" title="Abstract methods">Abstract methods</a>. Here’s an example of declaring an
      abstract class that has an abstract method.</p><pre class="programlisting">// This class is declared abstract and thus can't be instantiated.
abstract class AbstractContainer {
  // ...Define constructors, fields, methods...

  void updateChildren(); // Abstract method.
}</pre><p>The following class isn’t abstract, and thus can be instantiated
      even though it defines an abstract method.</p><pre class="programlisting">class SpecializedContainer extends AbstractContainer {
  // ...Define more constructors, fields, methods...

  void updateChildren() {
    // ...Implement updateChildren()...
  }

  void doSomething(); // Abstract method causes a warning but doesn't prevent instantiatation.
}</pre></div><div class="sect2" title="Implicit interfaces"><h3 id="id627258"/>Implicit interfaces</h3><p>Every class implicitly defines an interface containing all the
      instance members of the class and of any interfaces it implements. If
      you want to create a class A that supports class B’s API without
      inheriting B’s implementation, class A should implement the B
      interface.</p><p>A class implements one or more interfaces by declaring them in an
      <code class="literal">implements</code> clause and then providing
      the APIs required by the interfaces. For example:</p><pre class="programlisting">// A person. The implicit interface contains greet().
class Person {
  final _name;          // In the interface, but visible only in this library, thanks to _.
  Person(this._name);   // Not in the interface, since this is a constructor.
  String greet(who) =&gt; 'Hello, $who. I am $_name.'; // In the interface.
}

// An implementation of the Person interface.
class Imposter implements Person {
  final _name = "";      // We have to define this, but we don't use it.
  String greet(who) =&gt; 'Hi $who. Do you know who I am?';
}

greetBob(Person person) =&gt; person.greet('bob');

main() {
  print(greetBob(new Person('kathy')));
  print(greetBob(new Imposter()));
}</pre><p>Here’s an example of specifying that a class implements multiple
      interfaces:</p><pre class="programlisting">class Point <span class="bold"><strong>implements Comparable, Location</strong></span> {
  //...
}</pre></div><div class="sect2" title="Extending a class"><h3 id="id491080"/>Extending a class</h3><p>Use <code class="literal">extends</code> to create a
      subclass, and <code class="literal">super</code> to refer to the
      superclass.</p><pre class="programlisting">class Television {
  void turnOn() {
    _illuminateDisplay();
    _activateIrSensor();
  }
}

class SmartTelevision extends Television {
  void turnOn() {
    super.turnOn();
    _bootNetworkInterface();
    _initializeMemory();
    _upgradeApps();
  }
}</pre><p>Subclasses can override instance methods, getters, and
      setters.</p></div><div class="sect2" title="Class variables and methods"><h3 id="id444920"/>Class variables and methods</h3><p>Use the <code class="literal">static</code> keyword to
      implement class-wide variables and methods.</p><div class="sect3" title="Static variables"><h4 id="id367308"/>Static variables</h4><p>Static variables (class variables) are useful for class-wide
        state and constants.</p><pre class="programlisting">class Color {
  static const RED = const Color('red'); // A constant static variable.
  final String name;                     // An instance variable.
  const Color(this.name);                // A constant constructor.
}

main() {
  assert(Color.RED.name == 'red');
}</pre><p>Static variables aren’t initialized until they’re used.</p></div><div class="sect3" title="Static methods"><h4 id="id627288"/>Static methods</h4><p>Static methods (class methods) do not operate on an instance,
        and thus do not have access to <code class="literal">this</code>.</p><pre class="programlisting">class Point {
  num x;
  num y;
  Point(this.x, this.y);

  static num distanceBetween(Point a, Point b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
  }
}

main() {
  var a = new Point(2, 2);
  var b = new Point(4, 4);
  var distance = Point.distanceBetween(a,b);
  assert(distance &lt; 2.9 &amp;&amp; distance &gt; 2.8);
}</pre><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>Consider using top-level functions, instead of static methods,
          for common or widely used utilities and functionality.</p></div><p>You can use static methods as compile-time constants. For
        example, you can pass a static method as a parameter to a constant
        constructor.</div></aside></div><div class="sect1" title="Generics"><h2 id="generics"/>Generics</h2><p>If you look at the API documentation for the basic array type,
    <a class="ulink" href="http://api.dartlang.org/dart_core/List.html">List,</a>
    you’ll see that the type is actually <code class="literal">List&lt;E&gt;</code>. The &lt;...&gt; notation marks
    List as a <span class="emphasis"><em>generic</em></span> (or
    <span class="emphasis"><em>parameterized</em></span>) type—a type that has formal type
    parameters.</p><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>By convention, type variables have single-letter names, such as E,
      T, S, K, and V.</p></div><div class="sect2" title="Why use generics?"><h3 id="id313252"/>Why use generics?</h3><p>Because types are optional in Dart, you never
      <span class="emphasis"><em>have</em></span> to use generics. You might
      <span class="emphasis"><em>want</em></span> to, though, for the same reason you might want
      to use other types in your code: types (generic or not) let you document
      and annotate your code, making your intent clearer.</p><p>For example, if you intend for a list to contain only strings, you
      can declare it as <code class="literal">List&lt;String&gt;</code>
      (read that as <span class="quote">“<span class="quote">list of string</span>”</span>). That way you, your fellow
      programmers, and your tools (such as Dart Editor and the Dart VM in
      checked mode) can detect that assigning a non-string to the list is
      probably a mistake.</p><pre class="programlisting">var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
//...
names.add(42); // Fails in checked mode (succeeds in production mode).</pre><p>Another reason for using generics is to reduce code duplication.
      Generics let you share a single interface and implementation between
      many types, while still taking advantage of checked mode and static
      analysis early warnings. For example, say you create an interface for
      caching an object:</p><pre class="programlisting">abstract class ObjectCache {
  Object getByKey(String key);
  setByKey(String key, Object value);
}</pre><p>You discover that you want a string-specific version of this
      interface, so you create another interface:</p><pre class="programlisting">abstract class StringCache {
  String getByKey(String key);
  setByKey(String key, String value);
}</pre><p>Later, you decide you want a number-specific version of this
      interface... You get the idea.</p><p>Generic types can save you the trouble of creating all these
      interfaces. Instead, you can create a single interface that takes a type
      parameter:</p><pre class="programlisting">abstract class Cache&lt;T&gt; {
  T getByKey(String key);
  setByKey(String key, T value);
}</pre><p>In this code, T is the stand-in type. It’s a placeholder that you
      can think of as a type that a developer will define later.</p></div><div class="sect2" title="Using collection literals"><h3 id="generics-literals"/>Using collection literals</h3><p>List and map literals can be parameterized. Parameterized literals
      are just like the literals you’ve already seen, except that you add
      <code class="literal">&lt;<em class="replaceable"><code>type</code></em>&gt;</code> (for
      lists) or <code class="literal">&lt;<em class="replaceable"><code>keyType</code></em>,
      <em class="replaceable"><code>valueType</code></em>&gt;</code> (for maps) before the
      opening bracket. You might use parameterized literals when you want type
      warnings in checked mode. Here is example of using typed
      literals:</p><pre class="programlisting">var names = &lt;String&gt;['Seth', 'Kathy', 'Lars'];
var pages = &lt;String, String&gt;{
    'index.html':'Homepage',
    'robots.txt':'Hints for web robots',
    'humans.txt':'We are people, not machines' };</pre><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>Map literals always have string <span class="emphasis"><em>keys</em></span>, so
        their type is always <code class="literal">&lt;String,
        <em class="replaceable"><code>SomeType</code></em>&gt;</code>.</div></aside><div class="sect2" title="Using constructors"><h3 id="generics-constructors"/>Using constructors</h3><p>To specify one or more types when using a constructor, put the
      types in angle brackets (<code class="literal">&lt;...&gt;</code>)
      just after the class name. For example:</p><pre class="programlisting">var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
var nameSet = new Set&lt;String&gt;.from(names);</pre><p>The following code creates a map that has integer keys and values
      of type View:</p><pre class="programlisting">var views = new Map&lt;int, View&gt;();</pre></div><div class="sect2" title="Generic collections and the types they contain"><h3 id="generics-collections"/>Generic collections and the types they contain</h3><p>Dart generic types are <span class="emphasis"><em>reified</em></span>, which means
      that they carry their type information around at runtime. For example,
      you can test the type of a collection, even in production mode:</p><pre class="programlisting">var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
print(names is List&lt;String&gt;); // true</pre><p>However, the <code class="literal">is</code> expression
      checks the type of the <span class="emphasis"><em>collection</em></span> only—not of the
      objects inside it. In production mode, a List&lt;String&gt; might have
      some non-string items in it. The solution is to either check each item’s
      type or wrap item-manipulation code in an exception handler (see <a class="xref" href="ch02.html#exceptions" title="Exceptions">Exceptions</a>).</p><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>In contrast, generics in Java use <span class="emphasis"><em>erasure</em></span>,
        which means that generic type parameters are removed at runtime. In
        Java, you can test whether an object is a List, but you can’t test
        whether it’s a List&lt;String&gt;.</p></div><p>For more information about generics, see <a class="ulink" href="http://www.dartlang.org/articles/optional-types/">Optional Types in
      Dart.</a></p></div></div><div class="sect1" title="Libraries and visibility"><h2 id="libraries-and-visibility"/>Libraries and visibility</h2><p>The <code class="literal">import</code>, <code class="literal">part</code>, and <code class="literal">library</code> directives can help you create a modular
    and shareable code base. Libraries not only provide APIs, but are a unit
    of privacy: identifiers that start with an underscore (_) are visible only
    inside the library.</p><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong><span class="emphasis"><em>Every Dart app is a library</em></span>, even if it
      doesn’t use a library directive.</p></div><p>Libraries can be distributed using packages. See <a class="xref" href="ch04.html#ch04-tools-pub" title="pub: The Dart package manager">pub: The Dart package manager</a> for information about pub, a package manager
    included in the SDK.</p><div class="sect2" title="Using libraries"><h3 id="libraries-import"/>Using libraries</h3><p>Use <code class="literal">import</code> to specify how a
      namespace from one library is used in the scope of another
      library.</p><p>For example, Dart web apps generally use the <a class="ulink" href="http://api.dartlang.org/html.html">dart:html</a> library, which
      they can import like this:</p><pre class="programlisting">import 'dart:html';</pre><p>The only required argument to <code class="literal">import</code> is a URI<sup>[<a id="id548827" href="#ftn.id548827" class="footnote">1</a>]</sup> specifying the library. For built-in libraries, the URI
      has the special <code class="literal">dart:</code> scheme. For
      other libraries, you can use a file system path or the <code class="literal">package:</code> scheme. The <code class="literal">package:</code> scheme specifies libraries provided
      by a package manager such as the pub tool. For example:</p><pre class="programlisting">import 'dart:io';
import 'package:mylib/mylib.dart';
import 'package:utils/utils.dart';</pre><div class="sect3" title="Specifying a library prefix"><h4 id="libraries-prefix"/>Specifying a library prefix</h4><p>If you import two libraries that have conflicting identifiers,
        then you can specify a prefix for one or both libraries. For example,
        if library1 and library2 both have an Element class, then you might
        have code like this:</p><pre class="programlisting">import 'package:lib1/lib1.dart';
import 'package:lib2/lib2.dart' as lib2;
//...
var element1 = new Element();      // Uses Element from lib1.
var element2 = new lib2.Element(); // Uses Element from lib2.</pre></div><div class="sect3" title="Importing only part of a library"><h4 id="id313362"/>Importing only part of a library</h4><p>If you want to use only part of a library, you can selectively
        import the library. For example:</p><pre class="programlisting">import 'package:lib1/lib1.dart' show foo, bar; // Import only foo and bar from lib1.
import 'package:lib2/lib2.dart' hide foo;      // Import all names EXCEPT foo from lib2.</pre></div></div><div class="sect2" title="Implementing libraries"><h3 id="libraries-implementing"/>Implementing libraries</h3><p>Use the <code class="literal">part</code> directive to
      specify the files that are part of a library, and <code class="literal">library</code> to specify that a file declares a
      library.</p><div class="sect3" title="Using multiple files"><h4 id="libraries-part"/>Using multiple files</h4><p>Whether or not you specify a <code class="literal">library</code> directive, you can use <code class="literal">part</code> to specify the files that implement the
        current library.</p><pre class="programlisting">// No library directive; this file defines an anonymous library.
part 'ball.dart';   // Part of this library's implementation is in ball.dart.
part 'util.dart';   // Another part is in util.dart.

import 'dart:html'; // This app uses the HTML library.
//...
main() {            // Having a main() method makes this an app (and thus a library).
  //...
}</pre></div><div class="sect3" title="Declaring a library"><h4 id="libraries-library"/>Declaring a library</h4><p>To explicitly declare a library, use a <code class="literal">library</code> statement. For example:</p><pre class="programlisting">library ballgame;   // Declare that this is a library.

part 'ball.dart';   // Part of this library's implementation is in ball.dart.
part 'util.dart';   // Another part is in util.dart.

import 'dart:html'; // This app uses the HTML library.
//...
main() {            // We could move this code to another file in this library.
  //...
}</pre></div><div class="sect3" title="Associating a file with a library"><h4 id="libraries-source"/>Associating a file with a library</h4><p>You can use <code class="literal">part</code> followed by
        <code class="literal">of</code> (<code class="literal">part
        of</code>) in implementation files to specify that the file is
        associated with a library. Using <code class="literal">part
        of</code> is optional, but it helps tools such as Dart Editor.
        Here’s an example of using <code class="literal">part</code> and
        <code class="literal">part of</code>:</p><pre class="programlisting">// In ballgame.dart:
library ballgame;

import 'dart:utf';
// ...Other imports go here...

part 'ball.dart';
part 'util.dart';

//...


// In ball.dart:
part of ballgame;

// ...code goes here...


// In util.dart:
part of ballgame;

// ...code goes here...</pre></div><div class="sect3" title="Re-exporting libraries"><h4 id="id627546"/>Re-exporting libraries</h4><p>You can combine or repackage libraries by re-exporting part or
        all of them. For example, you might have a huge library that you
        implement as a set of smaller libraries. Or you might create a library
        that provides a subset of methods from another library.</p><pre class="programlisting"><span class="emphasis"><em>// In french.dart:</em></span>
library french;
hello() =&gt; print('Bonjour!');
goodbye() =&gt; print('Au Revoir!');

<span class="emphasis"><em>// In togo.dart:</em></span>
library togo;
import 'french.dart';
export 'french.dart' show hello;

<span class="emphasis"><em>// In another .dart file:
</em></span>import 'togo.dart';

void main() {
  hello();   //print bonjour
  goodbye(); //FAIL
}</pre></div></div></div><div class="sect1" title="Isolates"><h2 id="isolates"/>Isolates</h2><p>Modern web browsers, even on mobile platforms, run on multi-core
    CPUs. To take advantage of all those cores, developers traditionally use
    shared-memory threads running concurrently. However, shared-state
    concurrency is error prone and can lead to complicated code.</p><p>Instead of threads, all Dart code runs inside of
    <span class="emphasis"><em>isolates</em></span>. Each isolate has its own memory heap,
    ensuring that no isolate’s state is accessible from any other
    isolate.</p><p>Learn more about isolates in <a class="xref" href="ch03.html#ch03-dartisolate---concurrency-with-isolates" title="dart:isolate - Concurrency with isolates">dart:isolate - Concurrency with isolates</a>.</p></div><div class="sect1" title="Typedefs"><h2 id="typedefs"/>Typedefs</h2><p>In Dart, functions are objects, just like strings and numbers are
    objects. A <span class="emphasis"><em>typedef</em></span>, or <span class="emphasis"><em>function-type
    alias</em></span>, gives a function type a name that you can use when
    declaring fields and return types. A typedef retains type information when
    a function type is assigned to a variable.</p><p>Consider the following code, which does not use a typedef.</p><pre class="programlisting">class SortedCollection {
  Function compare;

  SortedCollection(int f(Object a, Object b)) {
    compare = f;
  }
}

int sort(Object a, Object b) =&gt; ... ; // Initial, broken implementation.

main() {
  SortedCollection collection = new SortedCollection(sort);

  // All we know is that compare is a function, but what type of function?
  assert(collection.compare is Function);
}</pre><p>Type information is lost when assigning <code class="literal">f</code> to <code class="literal">compare</code>.
    The type of <code class="literal">f</code> is <code class="literal">(Object, Object)</code> <span class="unicode">→</span> <code class="literal">int</code> (where
    <span class="unicode">→</span> means returns), yet the type of <code class="literal">compare</code> is Function. If we change the code to
    use explicit names and retain type information, both developers and tools
    can use that information.</p><pre class="programlisting"><span class="bold"><strong>typedef int Compare(Object a, Object b);</strong></span>

class SortedCollection {
  Compare compare;

  SortedCollection(this.compare);
}

int sort(Object a, Object b) =&gt; ... ; // Initial, broken implementation.

main() {
  SortedCollection collection = new SortedCollection(sort);
  assert(collection.compare is Function);
  assert(collection.compare is Compare);
}</pre><aside class="note" title="Note"><div class="alert alert-info"><strong>Note: </strong>Currently, typedefs are restricted to function types. We expect
      this to change.</p></div><p>Because typedefs are simply aliases, they offer a way to check the
    type of any function. For example:</p><pre class="programlisting">typedef int Compare(int a, int b);

int sort(int a, int b) =&gt; a - b;

main() {
  assert(sort is Compare);  // True!
}</pre></div><div class="sect1" title="Comments"><h2 id="comments"/>Comments</h2><p>Dart supports single-line comments, multi-line comments, and
    documentation comments.</p><div class="sect2" title="Single-line comments"><h3 id="id489543"/>Single-line comments</h3><p>A single-line comment begins with <code class="literal">//</code>. Everything between <code class="literal">//</code> and the end of line is ignored by the Dart
      compiler.</p><pre class="programlisting">main() {
  // TODO: refactor into an AbstractLlamaGreetingFactory?
  print('Welcome to my Llama farm!');
}</pre></div><div class="sect2" title="Multi-line comments"><h3 id="id627651"/>Multi-line comments</h3><p>A multi-line comment begins with <code class="literal">/*</code> and ends with <code class="literal">*/</code>. Everything between <code class="literal">/*</code> and <code class="literal">*/</code>
      is ignored by the Dart compiler (unless the comment is a documentation
      comment; see the next section). Multi-line comments can nest.</p><pre class="programlisting">main() {
  /*
   * This is a lot of work. Consider raising chickens.

  Llama larry = new Llama();
  larry.feed();
  larry.exercise();
  larry.clean();
   */
}</pre></div><div class="sect2" title="Documentation comments"><h3 id="comments-doc"/>Documentation comments</h3><p>Documentation comments are multi-line or single-line comments that
      begin with <code class="literal">/**</code> or <code class="literal">///</code>. Using <code class="literal">///</code> on consecutive lines has the same effect
      as a multi-line doc comment.</p><p>Inside a documentation comment, the Dart compiler ignores all text
      unless it is enclosed in brackets. Using brackets, you can refer to
      classes, methods, fields, top-level variables, functions, and
      parameters. The names in brackets are resolved in the lexical scope of
      the documented program element.</p><p>Here is an example of documentation comments with references to
      other classes and arguments:</p><pre class="programlisting">/**
 * The llama (Lama glama) is a domesticated South American
 * camelid, widely used as a meat and pack animal by Andean
 * cultures since pre-Hispanic times.
 */
class Llama {
  String name;

  /**
   * Feeds your llama [Food].
   * 
   * The typical llama eats one bale of hay per week.
   */
  void feed(Food food) {
    //...
  }

  /// Exercises your llama with an [activity] for
  /// [timeLimit] minutes.
  void exercise(Activity activity, int timeLimit) {
    //...
  }
}</pre><p>In the generated documentation, <code class="literal">[Food]</code> becomes a link to the API docs for the
      Food class.</p><p>To parse Dart code and generate HTML documentation, you can use
      Dart Editor, which in turn uses the SDK’s dartdoc package. For an
      example of generated documentation, see the <a class="ulink" href="http://api.dartlang.org">Dart API documentation</a>.</p></div></div><div class="sect1" title="Summary"><h2 id="summary"/>Summary</h2><p>This chapter summarized the commonly used features in the Dart
    language. For more information about the language, see the <a class="ulink" href="http://www.dartlang.org/docs/spec/">Dart Language
    Specification</a> and <a class="ulink" href="http://www.dartlang.org/articles/">articles</a> such as <a class="ulink" href="http://www.dartlang.org/articles/idiomatic-dart/">Idiomatic Dart</a>.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.id548827" href="#id548827" class="para">1</a>] </sup>URI stands for <em class="firstterm">uniform resource
          identifier</em>. URLs (<em class="firstterm">uniform resource
          locators</em>) are a common kind of URI.</p></div></div></div>
